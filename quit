[1mdiff --git a/ad b/ad[m
[1mdeleted file mode 100644[m
[1mindex 9b7dee2..0000000[m
[1m--- a/ad[m
[1m+++ /dev/null[m
[36m@@ -1,765 +0,0 @@[m
[31m-[1mdiff --git a/industry_alert/account/models.py b/industry_alert/account/models.py[m[m
[31m-[1mindex 71a8362..ec96231 100755[m[m
[31m-[1m--- a/industry_alert/account/models.py[m[m
[31m-[1m+++ b/industry_alert/account/models.py[m[m
[31m-[36m@@ -1,3 +1,65 @@[m[m
[31m- from django.db import models[m[m
[31m-[32m+[m[32mfrom django.contrib.auth.base_user import BaseUserManager, AbstractBaseUser[m[m
[31m-[32m+[m[32mfrom django.contrib.auth.models import PermissionsMixin[m[m
[31m- [m[m
[31m-[31m-# Create your models here.[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m# https://docs.djangoproject.com/en/3.2/ref/contrib/auth/[m[m
[31m-[32m+[m[32mclass AccountManager(BaseUserManager):[m[m
[31m-[32m+[m[32m    def create_user(self, email, password, name):[m[m
[31m-[32m+[m[32m        if not email:[m[m
[31m-[32m+[m[32m            raise ValueError('Users must have an email address')[m[m
[31m-[32m+[m[32m        print('어카운트')[m[m
[31m-[32m+[m[32m        # 이거 근데 꼭 해야하는건지는 모르겠음[m[m
[31m-[32m+[m[32m        user = self.model([m[m
[31m-[32m+[m[32m            # normalize_email()이거는 @domain에서 domain만 소문자로 만듬[m[m
[31m-[32m+[m[32m            email=self.normalize_email(email),[m[m
[31m-[32m+[m[32m            name=name[m[m
[31m-[32m+[m[32m        )[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m        # Sets the user’s password to the given raw string,[m[m
[31m-[32m+[m[32m        # taking care of the password hashing. Doesn’t save the User object.[m[m
[31m-[32m+[m[32m        user.set_password(password)[m[m
[31m-[32m+[m[32m        user.save()[m[m
[31m-[32m+[m[32m        return user[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    def create_superuser(self, email, password, name):[m[m
[31m-[32m+[m[32m        user = self.create_user([m[m
[31m-[32m+[m[32m            email=self.normalize_email(email),[m[m
[31m-[32m+[m[32m            password=password,[m[m
[31m-[32m+[m[32m            name=name[m[m
[31m-[32m+[m[32m        )[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m        # https://docs.djangoproject.com/en/3.2/ref/contrib/auth/[m[m
[31m-[32m+[m[32m        user.is_admin = True[m[m
[31m-[32m+[m[32m        user.is_active = True[m[m
[31m-[32m+[m[32m        user.is_superuser = True[m[m
[31m-[32m+[m[32m        user.save()[m[m
[31m-[32m+[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m# drf login[m[m
[31m-[32m+[m[32m# https://medium.com/geekculture/register-login-and-logout-users-in-django-rest-framework-51486390c29[m[m
[31m-[32m+[m[32m# https://github.com/django/django/blob/910ecd1b8df7678f45c3d507dde6bcb1faafa243/django/contrib/auth/base_user.py#L16 참조하기[m[m
[31m-[32m+[m[32m# 여기에 이름 생년월일 전화번호 같은 거 더 추가하기[m[m
[31m-[32m+[m[32mclass User(AbstractBaseUser, PermissionsMixin):[m[m
[31m-[32m+[m[32m    email = models.EmailField(verbose_name="email", max_length=60, unique=True, default=None)[m[m
[31m-[32m+[m[32m    password = models.CharField(verbose_name='password', max_length=255)[m[m
[31m-[32m+[m[32m    # charfield는 null true하는거아님 값이 비어있다를 표시하는게 빈스트링이랑 null 두가지가 다되면서 곱창남[m[m
[31m-[32m+[m[32m    name = models.CharField(verbose_name='name', max_length=30, default='', blank=True)[m[m
[31m-[32m+[m[32m    is_admin = models.BooleanField(default=False)[m[m
[31m-[32m+[m[32m    is_superuser = models.BooleanField(default=False)[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    # username으로 'email' field 사용함[m[m
[31m-[32m+[m[32m    USERNAME_FIELD = 'email'[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    # superuser 생성시 추가로 받을거[m[m
[31m-[32m+[m[32m    # https://docs.djangoproject.com/en/3.2/topics/auth/customizing/[m[m
[31m-[32m+[m[32m    REQUIRED_FIELDS = ['name'][m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    objects = AccountManager()[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    @property[m[m
[31m-[32m+[m[32m    def is_staff(self):[m[m
[31m-[32m+[m[32m        return self.is_admin[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    def __str__(self):[m[m
[31m-[32m+[m[32m        return str(self.email)[m[m
[31m-\ No newline at end of file[m[m
[31m-[1mdiff --git a/industry_alert/account/serializers.py b/industry_alert/account/serializers.py[m[m
[31m-[1mindex e69de29..2d98842 100644[m[m
[31m-[1m--- a/industry_alert/account/serializers.py[m[m
[31m-[1m+++ b/industry_alert/account/serializers.py[m[m
[31m-[36m@@ -0,0 +1,105 @@[m[m
[31m-[32m+[m[32mfrom rest_framework import serializers[m[m
[31m-[32m+[m[32mfrom .models import User[m[m
[31m-[32m+[m[32mfrom django.contrib.auth import get_user_model[m[m
[31m-[32m+[m[32mfrom rest_framework.authtoken.models import Token[m[m
[31m-[32m+[m[32m# get_user_model() : 클래스이다.[m[m
[31m-[32m+[m[32m# >>> get_user_model()[m[m
[31m-[32m+[m[32m# <class 'accounts.models.User'>[m[m
[31m-[32m+[m[32m# settings.AUTH_USER_MODEL : 문자열이다.[m[m
[31m-[32m+[m[32m# >>> settings.AUTH_USER_MODEL[m[m
[31m-[32m+[m[32m# >>> settings.AUTH_USER_MODEL[m[m
[31m-[32m+[m[32m# 'accounts.User'[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m# exceptions[m[m
[31m-[32m+[m[32mclass InvalidPassword(Exception):[m[m
[31m-[32m+[m[32m    pass[m[m
[31m-[32m+[m[32m# drf[m[m
[31m-[32m+[m[32m# 1. Serializer를 상속받은 LoginSerializer, 그리고 ModelSerializer를 상속받은 UserSerializer 두 개 작성[m[m
[31m-[32m+[m[32m# 2. 각 serializer는 아래와 같은 field를 가지고 이름에 맞는 동작을 해야함[m[m
[31m-[32m+[m[32m# https://eunjin3786.tistory.com/253[m[m
[31m-[32m+[m[32m# LoginSerializer[m[m
[31m-[32m+[m[32m#     쓰기전용 : username, password[m[m
[31m-[32m+[m[32m#     읽기전용 : token[m[m
[31m-[32m+[m[32m#     동작 : username과 password로 user인증을 하고, user의 token이 있으면 그것을, 없으면 새로 발행해서 돌려줌[m[m
[31m-[32m+[m[32mclass LoginSerializer(serializers.Serializer):[m[m
[31m-[32m+[m[32m    # write_only는 값을 받아서 create/update같은거만 하는거임[m[m
[31m-[32m+[m[32m    email = serializers.CharField(write_only=True)[m[m
[31m-[32m+[m[32m    password = serializers.CharField(write_only=True)[m[m
[31m-[32m+[m[32m    # 입력받는게 아니라 return으로 돌려주는 값이니까 read_only임[m[m
[31m-[32m+[m[32m    token = serializers.CharField(read_only=True)[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    # 로그인 확인[m[m
[31m-[32m+[m[32m    def create(self, validated_data):[m[m
[31m-[32m+[m[32m        email = validated_data['email'][m[m
[31m-[32m+[m[32m        password = validated_data['password'][m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m        user = User.objects.get(email=email)[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m        # 비밀번호 일치하면[m[m
[31m-[32m+[m[32m        if user.check_password(password):[m[m
[31m-[32m+[m[32m            token, _ = Token.objects.get_or_create(user=user)[m[m
[31m-[32m+[m[32m            # 이거 그냥 return token 하면 안돼는 이유는[m[m
[31m-[32m+[m[32m            # 밑의 유저시리얼라이저에서는 user.token에 token.key를 넣어줬는데[m[m
[31m-[32m+[m[32m            # 이거 리턴되는 object에서 getattr로 리턴 field들이 다 있으면 알아서 만들어주는건데[m[m
[31m-[32m+[m[32m            # 밑에서는 리턴이 user객체였고 이 객체에는 class Meta에 있는 3개의 field가 다 있어서 문제없이 된거고[m[m
[31m-[32m+[m[32m            # 지금은 token을 리턴하게 되면 token.token은 없고 token.key에 원하는값이있지[m[m
[31m-[32m+[m[32m            # 그래서 지금 에러인 {}가 가는거임[m[m
[31m-[32m+[m[32m            # token을 리턴하면 Token object인데 내가 serializer에 리턴하겠다고 명시한건[m[m
[31m-[32m+[m[32m            # token이라는 필드고 리턴한걸 serialize했을때 리턴 결과물에 token이라는 attribute가 있어야하는데[m[m
[31m-[32m+[m[32m            # token.token이 없으니 아무런 결과물이 안나오는거임[m[m
[31m-[32m+[m[32m            # 이제 {'token': token.key}를 리턴하면 getattr(리턴 결과물, 'token')하면[m[m
[31m-[32m+[m[32m            # 값이 있으니 결과물이 나오는거임[m[m
[31m-[32m+[m[32m            # 객체 serialize하면 __str__()로 나오는 결과물이 나옴[m[m
[31m-[32m+[m[32m            # print(getattr(token, 'key'))[m[m
[31m-[32m+[m[32m            print(token.key)[m[m
[31m-[32m+[m[32m            return {'token': token.key}[m[m
[31m-[32m+[m[32m        # 일치하는 비밀번호가 없으면[m[m
[31m-[32m+[m[32m        raise InvalidPassword[m[m
[31m-[32m+[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m# UserSerializer[m[m
[31m-[32m+[m[32m#     둘 다 : 필요한 모든 유저정보들[m[m
[31m-[32m+[m[32m#     쓰기전용 : password[m[m
[31m-[32m+[m[32m#     읽기전용 : token[m[m
[31m-[32m+[m[32m#     동작 : 받은 user정보를 통해 User를 생성하고, 생성된 user의 token을 새로 발행해서 password를 제외한 나머지 정보와 함께 돌려줌[m[m
[31m-[32m+[m[32mclass UserSerializer(serializers.ModelSerializer):[m[m
[31m-[32m+[m[32m    password = serializers.CharField(write_only=True)[m[m
[31m-[32m+[m[32m    token = serializers.CharField(read_only=True)[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    class Meta:[m[m
[31m-[32m+[m[32m        model = get_user_model()[m[m
[31m-[32m+[m[32m        fields = ['email', 'password', 'name', 'token'][m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    # 이거 근데 user.mode()에서 해주는데 없어야하는거 같음[m[m
[31m-[32m+[m[32m    # override하는거니까 인자 맞춰줘야함[m[m
[31m-[32m+[m[32m    def create(self, validated_data):[m[m
[31m-[32m+[m[32m        print("유저시리얼라이저 - create")[m[m
[31m-[32m+[m[32m        # 이제 이 validate_data는 validation도 끝났으니 정합한 데이터니 그냥 때려버리면 됨[m[m
[31m-[32m+[m[32m        # 이거 **은[m[m
[31m-[32m+[m[32m        # **d means "take all additional named arguments to this function[m[m
[31m-[32m+[m[32m        # and insert them into this parameter as dictionary entries."[m[m
[31m-[32m+[m[32m        # 이거 create_user가 인자를 2개 받아야하니 **validated_data[m[m
[31m-[32m+[m[32m        user = User.objects.create_user(**validated_data)[m[m
[31m-[32m+[m[32m        # 가져오거나 생성한값이랑[m[m
[31m-[32m+[m[32m        # 생성됐는지 가져온건지 여부를[m[m
[31m-[32m+[m[32m        # 튜플로줌[m[m
[31m-[32m+[m[32m        # 저게 생성으로 가져온 결과물이면 True[m[m
[31m-[32m+[m[32m        # 있던거 가져온거면 False[m[m
[31m-[32m+[m[32m        # _는 안쓸값은 _로 저장함[m[m
[31m-[32m+[m[32m        token, _ = Token.objects.get_or_create(user=user)[m[m
[31m-[32m+[m[32m        # 이거 가능한 이유는 user는 User의 인스턴스고 파이썬 클래스는 getter setter없이 걍 뭐든 할 수 있어서[m[m
[31m-[32m+[m[32m        # 이렇게 하면 token이 추가가 가능한거임[m[m
[31m-[32m+[m[32m        # 추가로 걍 객체를 serialize시키면 아까말한 __str__()값이 들어감[m[m
[31m-[32m+[m[32m        user.token = token[m[m
[31m-[32m+[m[32m        return user[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    def update(self, instance, validated_data):[m[m
[31m-[32m+[m[32m        # items()은 key, value 튜플쌍을 튜플로 리턴하는 함수임[m[m
[31m-[32m+[m[32m        print(instance.password)[m[m
[31m-[32m+[m[32m        for key, value in validated_data.items():[m[m
[31m-[32m+[m[32m            # 제일 첫번째 인자에 key가 있으면 True 없으면 False 반환하는게 hasattr이고[m[m
[31m-[32m+[m[32m            if hasattr(instance, key):[m[m
[31m-[32m+[m[32m                # 값 저장하는게 setattr[m[m
[31m-[32m+[m[32m                setattr(instance, key, value)[m[m
[31m-[32m+[m[32m        instance.save()[m[m
[31m-[32m+[m[32m        return instance[m[m
[31m-[1mdiff --git a/industry_alert/account/views.py b/industry_alert/account/views.py[m[m
[31m-[1mindex 91ea44a..37c670b 100755[m[m
[31m-[1m--- a/industry_alert/account/views.py[m[m
[31m-[1m+++ b/industry_alert/account/views.py[m[m
[31m-[36m@@ -1,3 +1,121 @@[m[m
[31m-[31m-from django.shortcuts import render[m[m
[31m-[32m+[m[32mfrom rest_framework import viewsets, serializers, status[m[m
[31m-[32m+[m[32mfrom rest_framework.decorators import action[m[m
[31m-[32m+[m[32mfrom rest_framework.response import Response[m[m
[31m-[32m+[m[32mfrom rest_framework.permissions import AllowAny, IsAuthenticated[m[m
[31m-[32m+[m[32mfrom rest_framework.authtoken.models import Token[m[m
[31m-[32m+[m[32mfrom .models import User[m[m
[31m-[32m+[m[32mfrom .serializers import LoginSerializer, UserSerializer, InvalidPassword[m[m
[31m- [m[m
[31m-[31m-# Create your views here.[m[m
[31m-[32m+[m[32m# drf login[m[m
[31m-[32m+[m[32m# https://stackoverflow.com/questions/26906630/django-rest-framework-authentication-credentials-were-not-provided 이거 지금 해결안되고있음[m[m
[31m-[32m+[m[32mclass AccountViewSet(viewsets.GenericViewSet):[m[m
[31m-[32m+[m[32m    # permission_classes = [AllowAny][m[m
[31m-[32m+[m[32m    queryset = User.objects.all()[m[m
[31m-[32m+[m[32m    serializer_class = UserSerializer[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    # @action은[m[m
[31m-[32m+[m[32m    # This decorator can be used to add any custom endpoints that don't fit into the standard create/update/delete style.[m[m
[31m-[32m+[m[32m    # @action decorator will respond to GET requests by default.[m[m
[31m-[32m+[m[32m    # We can use the methods argument if we wanted an action that responded to POST requests.[m[m
[31m-[32m+[m[32m    # /.../foo/bar나[m[m
[31m-[32m+[m[32m    # /.../foo/{pk}/bar[m[m
[31m-[32m+[m[32m    # 이런 api를 추가하고싶을때쓰는거임[m[m
[31m-[32m+[m[32m    # detail=False면 위 detail=True면 아래[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    # @action(detail=True, methods=['get'])[m[m
[31m-[32m+[m[32m    # def asd(self, request, pk):[m[m
[31m-[32m+[m[32m    # 이거면 http://localhost:8000/test/login/[pk]/asd 여기로 등록됨[m[m
[31m-[32m+[m[32m    # detail=False여야지만 http://localhost:8000/test/login/asd/로 감[m[m
[31m-[32m+[m[32m    # http GET http://127.0.0.1:8000/api/v1/user/asd[m[m
[31m-[32m+[m[32m    @action(methods=['get'], detail=False, permission_classes=[AllowAny])[m[m
[31m-[32m+[m[32m    def asd(self, request):[m[m
[31m-[32m+[m[32m        serializer = self.serializer_class(self.queryset, many=True)[m[m
[31m-[32m+[m[32m        return Response(serializer.data)[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    # /api/v1/user 로 GET요청 받을 user list api (UserSerializer 사용)[m[m
[31m-[32m+[m[32m    # http GET http://127.0.0.1:8000/api/v1/user "Authorization: Token 01ecad58c74bb6a6c52ab3f8cb6946cb7312e0d6"[m[m
[31m-[32m+[m[32m    def list(self, request):[m[m
[31m-[32m+[m[32m        # self.get_queryset() 이거로 queryset = User.objects.all() 이거 가져오는거임[m[m
[31m-[32m+[m[32m        queryset = self.get_queryset()[m[m
[31m-[32m+[m[32m        serializer = self.get_serializer(queryset, many=True)[m[m
[31m-[32m+[m[32m        return Response(serializer.data)[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    # /api/v1/user/pk 로 GET요청 받을 user retrieve api (UserSerializer사용)[m[m
[31m-[32m+[m[32m    # http GET http://127.0.0.1:8000/api/v1/user/48 "Authorization: Token 01ecad58c74bb6a6c52ab3f8cb6946cb7312e0d6"[m[m
[31m-[32m+[m[32m    def retrieve(self, request, pk):[m[m
[31m-[32m+[m[32m        # queryset과 pk값을 인자로 받아서,[m[m
[31m-[32m+[m[32m        # queryset.filter(pk=pk)로 queryset을 뽑고,[m[m
[31m-[32m+[m[32m        # instance = queryset.get()으로 객체만 뽑아서 리턴해 주는 메소드임[m[m
[31m-[32m+[m[32m        # => 결국, 위 코드는 Customer.objects.get(pk=pk) 리턴함[m[m
[31m-[32m+[m[32m        # https://velog.io/@jcinsh/RetrieveUpdateDestroyView-%EC%9D%B4%ED%95%B4 참조[m[m
[31m-[32m+[m[32m        # queryset = User.objects.all() 이거를 기반으로 하는거임[m[m
[31m-[32m+[m[32m        instance = self.get_object()[m[m
[31m-[32m+[m[32m        serializer = self.get_serializer(instance)[m[m
[31m-[32m+[m[32m        return Response(serializer.data)[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    # /api/v1/user/pk 로 PATCH 요청 받을 user update ap[m[m
[31m-[32m+[m[32m    # http PUT http://127.0.0.1:8000/api/v1/user/50 "Authorization: Token 01ecad58c74bb6a6c52ab3f8cb6946cb7312e0d6"[m[m
[31m-[32m+[m[32m    # 이거 비밀번호를 바꾸려면 userserilaier에서 비밀번호가 readonly여서 안보이니 비밀번호를 바꾸려면 serializer를 새로 만들어야함[m[m
[31m-[32m+[m[32m    def update(self, request, pk):[m[m
[31m-[32m+[m[32m        instance = self.get_object()[m[m
[31m-[32m+[m[32m        # data앞에 뭐가 있으니 업데이트함[m[m
[31m-[32m+[m[32m        serializer = self.get_serializer(instance, data=request.data, partial=True)[m[m
[31m-[32m+[m[32m        try:[m[m
[31m-[32m+[m[32m            serializer.is_valid(raise_exception=True)[m[m
[31m-[32m+[m[32m            serializer.save()[m[m
[31m-[32m+[m[32m            return Response(serializer.data)[m[m
[31m-[32m+[m[32m        except serializers.ValidationError:[m[m
[31m-[32m+[m[32m            return Response({"status": "failed", "errors": serializer.errors})[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    # /api/v1/user/pk 로 DELETE 요청 받을 user delete api (Serializer 사용 x)[m[m
[31m-[32m+[m[32m    # http DELETE http://127.0.0.1:8000/api/v1/user/2000 "Authorization: Token 01ecad58c74bb6a6c52ab3f8cb6946cb7312e0d6"[m[m
[31m-[32m+[m[32m    def delete(self, request, pk):[m[m
[31m-[32m+[m[32m        print("in delete")[m[m
[31m-[32m+[m[32m        instance = self.get_object()[m[m
[31m-[32m+[m[32m        instance.delete()[m[m
[31m-[32m+[m[32m        return Response({'success': True}, status=status.HTTP_204_NO_CONTENT)[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    # /api/v1/user 로 POST요청을 받을 registration api (UserSerializer 사용)[m[m
[31m-[32m+[m[32m    # http POST http://127.0.0.1:8000/api/v1/user/register email="id@gmail.com" password="pw"[m[m
[31m-[32m+[m[32m    @action(detail=False, methods=['post'], permission_classes=[AllowAny])[m[m
[31m-[32m+[m[32m    def register(self, request):[m[m
[31m-[32m+[m[32m        serializer = self.get_serializer(data=request.data)[m[m
[31m-[32m+[m[32m        try:[m[m
[31m-[32m+[m[32m            serializer.is_valid(raise_exception=True)[m[m
[31m-[32m+[m[32m            # 이거 save()했을때 불려오는 method는[m[m
[31m-[32m+[m[32m            # serializer = UserSerializer(data=request.data)에서 data앞에 뭐가 없으면[m[m
[31m-[32m+[m[32m            # UserSerializer.create()를 불러오는거임[m[m
[31m-[32m+[m[32m            serializer.save()[m[m
[31m-[32m+[m[32m            # 이거 pw는 write_only라서 안보임[m[m
[31m-[32m+[m[32m            print(serializer.data)[m[m
[31m-[32m+[m[32m            return Response(serializer.data)[m[m
[31m-[32m+[m[32m        except serializers.ValidationError:[m[m
[31m-[32m+[m[32m            return Response({"status": "failed", "errors": serializer.errors})[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    # /api/v1/user/login 으로 POST요청을 받을 login api (LoginSerializer 사용)[m[m
[31m-[32m+[m[32m    # http POST http://127.0.0.1:8000/api/v1/user/login email="id@gmail.com" password="pw"[m[m
[31m-[32m+[m[32m    # 로그아웃 안하고 서버가 그냥 닫아지면 토큰 값이 유지되는거 같음 어떻게 해결해야함?[m[m
[31m-[32m+[m[32m    # 이거 get_or_create로 하기때문에 같은거임 안그러면 서버껐다켰는데 애들다 토큰 날아가서 다 에러나거나 로그인페이지로 날아감[m[m
[31m-[32m+[m[32m    # 해결하기 위해서는 토큰에 만료기한을 두고 토큰유출대도 credential이 없으면 만료시점이후에는 무효처리되도록 다시로그인시켜보는거지[m[m
[31m-[32m+[m[32m    @action(detail=False, methods=['post'], permission_classes=[AllowAny])[m[m
[31m-[32m+[m[32m    def login(self, request):[m[m
[31m-[32m+[m[32m        serializer = LoginSerializer(data=request.data)[m[m
[31m-[32m+[m[32m        try:[m[m
[31m-[32m+[m[32m            serializer.is_valid(raise_exception=True)[m[m
[31m-[32m+[m[32m            serializer.save()[m[m
[31m-[32m+[m[32m            return Response(serializer.data)[m[m
[31m-[32m+[m[32m        except InvalidPassword:[m[m
[31m-[32m+[m[32m            return Response({'success': False, 'error': '패스워드가 일치하지 않습니다'}, status=status.HTTP_400_BAD_REQUEST)[m[m
[31m-[32m+[m[32m        # 이거는 user = User.objects.get(email=email)에서 없으면 자동으로 raise됨[m[m
[31m-[32m+[m[32m        except User.DoesNotExist:[m[m
[31m-[32m+[m[32m            return Response({'success': False, 'error': '유저가 존재하지 않습니다'}, status=status.HTTP_400_BAD_REQUEST)[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    # /api/v1/user/logout 으로 DELETE 요청을 받을 logout api(Serializer 사용 x)[m[m
[31m-[32m+[m[32m    # http POST http://127.0.0.1:8000/api/v1/user/logout "Authorization: Token f44c39fec18227d5aa555dcbd20aa7d56d0f55ef"[m[m
[31m-[32m+[m[32m    @action(detail=False, methods=['post'], permission_classes=[IsAuthenticated])[m[m
[31m-[32m+[m[32m    def logout(self, request):[m[m
[31m-[32m+[m[32m        request.user.auth_token.delete()[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m        return Response({'success': "로그아웃 성공"}, status=status.HTTP_200_OK)[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m    # 특정 유저가 publish 한 post 보기[m[m
[31m-\ No newline at end of file[m[m
[31m-[1mdiff --git a/industry_alert/blog/models.py b/industry_alert/blog/models.py[m[m
[31m-[1mindex d486f8e..c380231 100644[m[m
[31m-[1m--- a/industry_alert/blog/models.py[m[m
[31m-[1m+++ b/industry_alert/blog/models.py[m[m
[31m-[36m@@ -2,16 +2,10 @@[m [mfrom django.conf import settings[m[m
[31m- from django.db import models[m[m
[31m- from django.utils import timezone[m[m
[31m- [m[m
[31m-[31m-# drf login[m[m
[31m-[31m-from django.contrib.auth.base_user import BaseUserManager, AbstractBaseUser[m[m
[31m-[31m-from django.contrib.auth.models import PermissionsMixin[m[m
[31m-[31m-[m[m
[31m- # image[m[m
[31m- from django.contrib.contenttypes.fields import GenericForeignKey[m[m
[31m- from django.contrib.contenttypes.models import ContentType[m[m
[31m- from django.contrib.contenttypes.fields import GenericRelation[m[m
[31m-[31m-# uuid[m[m
[31m-[31m-from uuid import uuid4[m[m
[31m- [m[m
[31m- class EntryImage(models.Model):[m[m
[31m-     def productFile(instance, filename):[m[m
[31m-[36m@@ -83,66 +77,4 @@[m [mclass Comment(models.Model):[m[m
[31m-         self.save()[m[m
[31m- [m[m
[31m-     def __str__(self):[m[m
[31m-[31m-        return self.text[m[m
[31m-[31m-[m[m
[31m-[31m-[m[m
[31m-[31m-# https://docs.djangoproject.com/en/3.2/ref/contrib/auth/[m[m
[31m-[31m-class AccountManager(BaseUserManager):[m[m
[31m-[31m-    def create_user(self, email, password, name):[m[m
[31m-[31m-        if not email:[m[m
[31m-[31m-            raise ValueError('Users must have an email address')[m[m
[31m-[31m-        print('어카운트')[m[m
[31m-[31m-        # 이거 근데 꼭 해야하는건지는 모르겠음[m[m
[31m-[31m-        user = self.model([m[m
[31m-[31m-            # normalize_email()이거는 @domain에서 domain만 소문자로 만듬[m[m
[31m-[31m-            email=self.normalize_email(email),[m[m
[31m-[31m-            name=name[m[m
[31m-[31m-        )[m[m
[31m-[31m-[m[m
[31m-[31m-        # Sets the user’s password to the given raw string,[m[m
[31m-[31m-        # taking care of the password hashing. Doesn’t save the User object.[m[m
[31m-[31m-        user.set_password(password)[m[m
[31m-[31m-        user.save()[m[m
[31m-[31m-        return user[m[m
[31m-[31m-[m[m
[31m-[31m-    def create_superuser(self, email, password, name):[m[m
[31m-[31m-        user = self.create_user([m[m
[31m-[31m-            email=self.normalize_email(email),[m[m
[31m-[31m-            password=password,[m[m
[31m-[31m-            name=name[m[m
[31m-[31m-        )[m[m
[31m-[31m-[m[m
[31m-[31m-        # https://docs.djangoproject.com/en/3.2/ref/contrib/auth/[m[m
[31m-[31m-        user.is_admin = True[m[m
[31m-[31m-        user.is_active=True[m[m
[31m-[31m-        user.is_superuser = True[m[m
[31m-[31m-        user.save()[m[m
[31m-[31m-[m[m
[31m-[31m-[m[m
[31m-[31m-# drf login[m[m
[31m-[31m-# https://medium.com/geekculture/register-login-and-logout-users-in-django-rest-framework-51486390c29[m[m
[31m-[31m-# https://github.com/django/django/blob/910ecd1b8df7678f45c3d507dde6bcb1faafa243/django/contrib/auth/base_user.py#L16 참조하기[m[m
[31m-[31m-# 여기에 이름 생년월일 전화번호 같은 거 더 추가하기[m[m
[31m-[31m-class User(AbstractBaseUser, PermissionsMixin):[m[m
[31m-[31m-    email = models.EmailField(verbose_name="email", max_length=60, unique=True, default=None)[m[m
[31m-[31m-    password = models.CharField(verbose_name='password',max_length=255)[m[m
[31m-[31m-    # charfield는 null true하는거아님 값이 비어있다를 표시하는게 빈스트링이랑 null 두가지가 다되면서 곱창남[m[m
[31m-[31m-    name = models.CharField(verbose_name='name', max_length=30, default='', blank=True)[m[m
[31m-[31m-    is_admin = models.BooleanField(default=False)[m[m
[31m-[31m-    is_superuser = models.BooleanField(default=False)[m[m
[31m-[31m-[m[m
[31m-[31m-    # username으로 'email' field 사용함[m[m
[31m-[31m-    USERNAME_FIELD = 'email'[m[m
[31m-[31m-[m[m
[31m-[31m-    # superuser 생성시 추가로 받을거[m[m
[31m-[31m-    # https://docs.djangoproject.com/en/3.2/topics/auth/customizing/[m[m
[31m-[31m-    REQUIRED_FIELDS = ['name'][m[m
[31m-[31m-    [m[m
[31m-[31m-    objects = AccountManager()[m[m
[31m-[31m-[m[m
[31m-[31m-    @property[m[m
[31m-[31m-    def is_staff(self):[m[m
[31m-[31m-        return self.is_admin[m[m
[31m-[31m-[m[m
[31m-[31m-    def __str__(self):[m[m
[31m-[31m-        return str(self.email)[m[m
[31m-[32m+[m[32m        return self.text[m[m
[31m-\ No newline at end of file[m[m
[31m-[1mdiff --git a/industry_alert/blog/serializers.py b/industry_alert/blog/serializers.py[m[m
[31m-[1mindex e4fda24..6a54560 100644[m[m
[31m-[1m--- a/industry_alert/blog/serializers.py[m[m
[31m-[1m+++ b/industry_alert/blog/serializers.py[m[m
[31m-[36m@@ -1,9 +1,10 @@[m[m
[31m-[31m-from rest_framework import serializers[m[m
[31m-[31m-from .models import Post, Comment, User, EntryImage[m[m
[31m-[32m+[m[32mfrom django.contrib.auth import get_user_model[m[m
[31m-[32m+[m[32mfrom .models import Post, Comment, EntryImage[m[m
[31m- [m[m
[31m- # drf[m[m
[31m-[31m-from django.contrib.auth import get_user_model[m[m
[31m-[32m+[m[32mfrom rest_framework import serializers[m[m
[31m- from rest_framework.authtoken.models import Token[m[m
[31m-[32m+[m[32mfrom rest_framework.exceptions import ValidationError[m[m
[31m- # get_user_model() : 클래스이다.[m[m
[31m- # >>> get_user_model()[m[m
[31m- # <class 'accounts.models.User'>[m[m
[31m-[36m@@ -23,11 +24,6 @@[m [mclass ImageSerializer(serializers.ModelSerializer):[m[m
[31m-         # 'content_object' 이거는 db에 실제로 써지는게 아니라서 없어도 됨[m[m
[31m-         fields = ['id', 'image', 'content_type', 'object_id'][m[m
[31m- [m[m
[31m-[31m-# 이거 따로 .py파서 옮기기[m[m
[31m-[31m-class InvalidPassword(Exception):[m[m
[31m-[31m-    pass[m[m
[31m-[31m-[m[m
[31m-[31m-[m[m
[31m- class PostSerializer(serializers.ModelSerializer):[m[m
[31m-     # https://github.com/encode/django-rest-framework/blob/fdb49314754ff13d91c6eec7ccdb8ece52bea9eb/rest_framework/fields.py#L286[m[m
[31m-     author = serializers.HiddenField(default=serializers.CurrentUserDefault())[m[m
[31m-[36m@@ -101,96 +97,4 @@[m [mclass CommentSerializer(serializers.ModelSerializer):[m[m
[31m-     def validate_text(self, value):[m[m
[31m-         if '시벌' in value:[m[m
[31m-             raise ValidationError('욕하지마라')[m[m
[31m-[31m-        return value[m[m
[31m-[31m-[m[m
[31m-[31m-[m[m
[31m-[31m-# drf[m[m
[31m-[31m-# 1. Serializer를 상속받은 LoginSerializer, 그리고 ModelSerializer를 상속받은 UserSerializer 두 개 작성[m[m
[31m-[31m-# 2. 각 serializer는 아래와 같은 field를 가지고 이름에 맞는 동작을 해야함[m[m
[31m-[31m-# https://eunjin3786.tistory.com/253[m[m
[31m-[31m-# LoginSerializer[m[m
[31m-[31m-#     쓰기전용 : username, password[m[m
[31m-[31m-#     읽기전용 : token[m[m
[31m-[31m-#     동작 : username과 password로 user인증을 하고, user의 token이 있으면 그것을, 없으면 새로 발행해서 돌려줌[m[m
[31m-[31m-class LoginSerializer(serializers.Serializer):[m[m
[31m-[31m-    # write_only는 값을 받아서 create/update같은거만 하는거임[m[m
[31m-[31m-    email = serializers.CharField(write_only=True)[m[m
[31m-[31m-    password = serializers.CharField(write_only=True)[m[m
[31m-[31m-    # 입력받는게 아니라 return으로 돌려주는 값이니까 read_only임[m[m
[31m-[31m-    token = serializers.CharField(read_only=True)[m[m
[31m-[31m-[m[m
[31m-[31m-    # 로그인 확인[m[m
[31m-[31m-    def create(self, validated_data):[m[m
[31m-[31m-        email = validated_data['email'][m[m
[31m-[31m-        password = validated_data['password'][m[m
[31m-[31m-[m[m
[31m-[31m-        user = User.objects.get(email=email)[m[m
[31m-[31m-[m[m
[31m-[31m-        # 비밀번호 일치하면[m[m
[31m-[31m-        if user.check_password(password):[m[m
[31m-[31m-            token, _ = Token.objects.get_or_create(user=user)[m[m
[31m-[31m-            # 이거 그냥 return token 하면 안돼는 이유는[m[m
[31m-[31m-            # 밑의 유저시리얼라이저에서는 user.token에 token.key를 넣어줬는데[m[m
[31m-[31m-            # 이거 리턴되는 object에서 getattr로 리턴 field들이 다 있으면 알아서 만들어주는건데[m[m
[31m-[31m-            # 밑에서는 리턴이 user객체였고 이 객체에는 class Meta에 있는 3개의 field가 다 있어서 문제없이 된거고[m[m
[31m-[31m-            # 지금은 token을 리턴하게 되면 token.token은 없고 token.key에 원하는값이있지[m[m
[31m-[31m-            # 그래서 지금 에러인 {}가 가는거임[m[m
[31m-[31m-            # token을 리턴하면 Token object인데 내가 serializer에 리턴하겠다고 명시한건[m[m
[31m-[31m-            # token이라는 필드고 리턴한걸 serialize했을때 리턴 결과물에 token이라는 attribute가 있어야하는데[m[m
[31m-[31m-            # token.token이 없으니 아무런 결과물이 안나오는거임[m[m
[31m-[31m-            # 이제 {'token': token.key}를 리턴하면 getattr(리턴 결과물, 'token')하면[m[m
[31m-[31m-            # 값이 있으니 결과물이 나오는거임[m[m
[31m-[31m-            # 객체 serialize하면 __str__()로 나오는 결과물이 나옴[m[m
[31m-[31m-            # print(getattr(token, 'key'))[m[m
[31m-[31m-            print(token.key)[m[m
[31m-[31m-            return {'token': token.key}[m[m
[31m-[31m-        # 일치하는 비밀번호가 없으면[m[m
[31m-[31m-        raise InvalidPassword[m[m
[31m-[31m-[m[m
[31m-[31m-[m[m
[31m-[31m-# UserSerializer[m[m
[31m-[31m-#     둘 다 : 필요한 모든 유저정보들[m[m
[31m-[31m-#     쓰기전용 : password[m[m
[31m-[31m-#     읽기전용 : token[m[m
[31m-[31m-#     동작 : 받은 user정보를 통해 User를 생성하고, 생성된 user의 token을 새로 발행해서 password를 제외한 나머지 정보와 함께 돌려줌[m[m
[31m-[31m-class UserSerializer(serializers.ModelSerializer):[m[m
[31m-[31m-    password = serializers.CharField(write_only=True)[m[m
[31m-[31m-    token = serializers.CharField(read_only=True)[m[m
[31m-[31m-[m[m
[31m-[31m-    class Meta:[m[m
[31m-[31m-        model = get_user_model()[m[m
[31m-[31m-        fields = ['email', 'password', 'name', 'token'][m[m
[31m-[31m-[m[m
[31m-[31m-    # 이거 근데 user.mode()에서 해주는데 없어야하는거 같음[m[m
[31m-[31m-    # override하는거니까 인자 맞춰줘야함[m[m
[31m-[31m-    def create(self, validated_data):[m[m
[31m-[31m-        print("유저시리얼라이저 - create")[m[m
[31m-[31m-        # 이제 이 validate_data는 validation도 끝났으니 정합한 데이터니 그냥 때려버리면 됨[m[m
[31m-[31m-        # 이거 **은[m[m
[31m-[31m-        # **d means "take all additional named arguments to this function[m[m
[31m-[31m-        # and insert them into this parameter as dictionary entries."[m[m
[31m-[31m-        # 이거 create_user가 인자를 2개 받아야하니 **validated_data[m[m
[31m-[31m-        user = User.objects.create_user(**validated_data)[m[m
[31m-[31m-        # 가져오거나 생성한값이랑[m[m
[31m-[31m-        # 생성됐는지 가져온건지 여부를[m[m
[31m-[31m-        # 튜플로줌[m[m
[31m-[31m-        # 저게 생성으로 가져온 결과물이면 True[m[m
[31m-[31m-        # 있던거 가져온거면 False[m[m
[31m-[31m-        # _는 안쓸값은 _로 저장함[m[m
[31m-[31m-        token, _ = Token.objects.get_or_create(user=user)[m[m
[31m-[31m-        # 이거 가능한 이유는 user는 User의 인스턴스고 파이썬 클래스는 getter setter없이 걍 뭐든 할 수 있어서[m[m
[31m-[31m-        # 이렇게 하면 token이 추가가 가능한거임[m[m
[31m-[31m-        # 추가로 걍 객체를 serialize시키면 아까말한 __str__()값이 들어감[m[m
[31m-[31m-        user.token = token[m[m
[31m-[31m-        return user[m[m
[31m-[31m-[m[m
[31m-[31m-    def update(self, instance, validated_data):[m[m
[31m-[31m-        # items()은 key, value 튜플쌍을 튜플로 리턴하는 함수임[m[m
[31m-[31m-        print(instance.password)[m[m
[31m-[31m-        for key, value in validated_data.items():[m[m
[31m-[31m-            # 제일 첫번째 인자에 key가 있으면 True 없으면 False 반환하는게 hasattr이고[m[m
[31m-[31m-            if hasattr(instance, key):[m[m
[31m-[31m-                # 값 저장하는게 setattr[m[m
[31m-[31m-                setattr(instance, key, value)[m[m
[31m-[31m-        instance.save()[m[m
[31m-[31m-        return instance[m[m
[31m-[32m+[m[32m        return value[m[m
[31m-\ No newline at end of file[m[m
[31m-[1mdiff --git a/industry_alert/blog/views.py b/industry_alert/blog/views.py[m[m
[31m-[1mindex f27e65c..5397489 100644[m[m
[31m-[1m--- a/industry_alert/blog/views.py[m[m
[31m-[1m+++ b/industry_alert/blog/views.py[m[m
[31m-[36m@@ -3,6 +3,7 @@[m [mfrom django.utils import timezone # timezone.now() 사용하기 위함임[m[m
[31m- from rest_framework.exceptions import ParseError[m[m
[31m- [m[m
[31m- from .models import Post, Comment # Post모델, Comment모델을 불러오기 위함임[m[m
[31m-[32m+[m[32mfrom .serializers import PostSerializer, CommentSerializer[m[m
[31m- from .forms import PostForm, CommentForm[m[m
[31m- from django.shortcuts import redirect[m[m
[31m- from django.contrib.auth.decorators import login_required[m[m
[31m-[36m@@ -11,8 +12,6 @@[m [mfrom django.contrib.auth.decorators import login_required[m[m
[31m- from rest_framework import viewsets[m[m
[31m- from rest_framework.decorators import action[m[m
[31m- from rest_framework.response import Response[m[m
[31m-[31m-from blog.models import Post, Comment, User[m[m
[31m-[31m-from blog.serializers import PostSerializer, CommentSerializer, LoginSerializer, UserSerializer, InvalidPassword[m[m
[31m- from rest_framework.permissions import AllowAny, IsAuthenticated[m[m
[31m- from rest_framework import serializers[m[m
[31m- from rest_framework import status[m[m
[31m-[36m@@ -112,55 +111,31 @@[m [mclass EveLoginViewSet(viewsets.GenericViewSet):[m[m
[31m-                 headers=headers,[m[m
[31m-                 data=body[m[m
[31m-             )[m[m
[31m-[31m-            res.raise_for_status()[m[m
[31m-             res_dict = res.json()[m[m
[31m-[31m-        except requests.exceptions.ConnectionError as e:[m[m
[31m-[31m-            return Response({"status": "failed", "errors": str(e)})[m[m
[31m-[31m-        except requests.exceptions.Timeout as e:[m[m
[31m-[31m-            return Response({"status": "failed", "errors": str(e)})[m[m
[31m-[31m-        except requests.exceptions.TooManyRedirects as e:[m[m
[31m-[31m-            return Response({"status": "failed", "errors": str(e)})[m[m
[31m-[31m-        # raise_for_status()[m[m
[31m-[31m-        except requests.exceptions.HTTPError as e:[m[m
[31m-[31m-            return Response({"status": "failed", "errors": str(e)})[m[m
[31m-[31m-        # res.json()[m[m
[31m-[31m-        except requests.exceptions.JSONDecodeError as e:[m[m
[31m-[31m-            return Response({"status": "failed", "errors": str(e)})[m[m
[31m-[31m-        # 위에서 걸리지 않은 다른 모든 exceptions[m[m
[31m-[31m-        except requests.exceptions.RequestException as e:[m[m
[31m-[31m-            return Response({"status": "failed", "errors": str(e)})[m[m
[31m-[31m-        [m[m
[31m-[31m-        if 'error' in res_dict:[m[m
[31m-[31m-            return Response({"status": "failed", "errors": "something went wrong"})[m[m
[31m-[32m+[m[32m            access_token = res_dict.get('access_token')[m[m
[31m-[32m+[m[32m            # 이거 어차피 여기서 access_token이 안온거면 연결이  실패한거임[m[m
[31m-[32m+[m[32m            # 그러니까 예외는 여기서 keyError하나만 잡고 나머지 다른 에러는[m[m
[31m-[32m+[m[32m            # django에서 500에러 주니 이거 logging 해서 잡아내면됨[m[m
[31m-[32m+[m[32m            # 클라이언트는 잡다한 예외 상황 알 필요없고 여기 기준으로는 이브와의 서버 통신을 실패한거만 알면 되기 떄문에[m[m
[31m-[32m+[m[32m            # 그냥 access_token 없으면 이브 서버와의 통신이 실패한거니 실패했다고 알려주면됨.[m[m
[31m-[32m+[m[32m        except KeyError:[m[m
[31m-[32m+[m[32m            return Response({"status": "failed", "errors": "이브서버와 통신을 실패했습니다."})[m[m
[31m-[32m+[m[m
[31m-         # If the previous step was done correctly, the EVE SSO will respond with a JSON payload containing an access token (which is a Json Web Token) [m[m
[31m-         # and a refresh token that looks like this (Anything wrapped by <> will look different for you):[m[m
[31m-[31m-        # 이게 res에 저장됨[m[m
[31m-[31m-        acc = 'Bearer ' + res_dict['access_token'][m[m
[31m-[32m+[m[32m        # 여기서 말하는 JSON payload가 위의 res에 저장됨[m[m
[31m-[32m+[m[32m        acc = 'Bearer ' + access_token[m[m
[31m-         try:[m[m
[31m-             character_res = requests.get([m[m
[31m-                 "https://login.eveonline.com/oauth/verify",[m[m
[31m-[31m-                headers= {'Authorization': acc}[m[m
[31m-[32m+[m[32m                headers={"Authorization": acc}[m[m
[31m-             )[m[m
[31m-[31m-            character_res.raise_for_status()[m[m
[31m-             character_dict = character_res.json()[m[m
[31m-[31m-        except requests.exceptions.ConnectionError as e:[m[m
[31m-[31m-            return Response({"status": "failed", "errors": str(e)})[m[m
[31m-[31m-        except requests.exceptions.Timeout as e:[m[m
[31m-[31m-            return Response({"status": "failed", "errors": str(e)})[m[m
[31m-[31m-        except requests.exceptions.TooManyRedirects as e:[m[m
[31m-[31m-            return Response({"status": "failed", "errors": str(e)})[m[m
[31m-[31m-        # raise_for_status()[m[m
[31m-[31m-        except requests.exceptions.HTTPError as e:[m[m
[31m-[31m-            return Response({"status": "failed", "errors": str(e)})[m[m
[31m-[31m-        # res.json()[m[m
[31m-[31m-        except requests.exceptions.JSONDecodeError as e:[m[m
[31m-[31m-            return Response({"status": "failed", "errors": str(e)})[m[m
[31m-[31m-        # 위에서 걸리지 않은 다른 모든 exceptions[m[m
[31m-[31m-        except requests.exceptions.RequestException as e:[m[m
[31m-[31m-            return Response({"status": "failed", "errors": str(e)})[m[m
[31m-[31m-[m[m
[31m-[31m-        # urll = 'https://esi.evetech.net/latest/characters/' + str(character_id)+ '/industry/jobs/?datasource=tranquility'[m[m
[31m-[31m-        esi_request_url = self.url_creater(character_dict['CharacterID'], 'industry_jobs')[m[m
[31m-[32m+[m[32m            character_id = character_dict['CharacterID'][m[m
[31m-[32m+[m[32m        except KeyError:[m[m
[31m-[32m+[m[32m            return Response({"status": "failed", "errors": "이브서버와 통신을 실패했습니다."})[m[m
[31m-[32m+[m[m
[31m-[32m+[m[32m        esi_request_url = self.url_creater(character_id, 'industry_jobs')[m[m
[31m-         [m[m
[31m-         res4 = requests.get([m[m
[31m-              esi_request_url,[m[m
[31m-[36m@@ -404,120 +379,6 @@[m [mclass CommentViewSet(viewsets.GenericViewSet):[m[m
[31m-         except serializers.ValidationError:[m[m
[31m-             return Response({"status": "failed", "errors": serializer.errors})[m[m
[31m- [m[m
[31m-[31m-# drf login[m[m
[31m-[31m-# https://stackoverflow.com/questions/26906630/django-rest-framework-authentication-credentials-were-not-provided 이거 지금 해결안되고있음[m[m
[31m-[31m-class AccountViewSet(viewsets.GenericViewSet):[m[m
[31m-[31m-    # permission_classes = [AllowAny][m[m
[31m-[31m-    queryset = User.objects.all()[m[m
[31m-[31m-    serializer_class = UserSerializer[m[m
[31m-[31m-[m[m
[31m-[31m-    # @action은 [m[m
[31m-[31m-    # This decorator can be used to add any custom endpoints that don't fit into the standard create/update/delete style.[m[m
[31m-[31m-    # @action decorator will respond to GET requests by default. [m[m
[31m-[31m-    # We can use the methods argument if we wanted an action that responded to POST requests.[m[m
[31m-[31m-    # /.../foo/bar나[m[m
[31m-[31m-    # /.../foo/{pk}/bar[m[m
[31m-[31m-    # 이런 api를 추가하고싶을때쓰는거임[m[m
[31m-[31m-    # detail=False면 위 detail=True면 아래[m[m
[31m-[31m-[m[m
[31m-[31m-    # @action(detail=True, methods=['get'])[m[m
[31m-[31m-    # def asd(self, request, pk):[m[m
[31m-[31m-    # 이거면 http://localhost:8000/test/login/[pk]/asd 여기로 등록됨[m[m
[31m-[31m-    # detail=False여야지만 http://localhost:8000/test/login/asd/로 감[m[m
[31m-[31m-    # http GET http://127.0.0.1:8000/api/v1/user/asd[m[m
[31m-[31m-    @action(methods=['get'], detail=False, permission_classes=[AllowAny])[m[m
[31m-[31m-    def asd(self, request):[m[m
[31m-[31m-        serializer = self.serializer_class(self.queryset, many=True)[m[m
[31m-[31m-        return Response(serializer.data)[m[m
[31m-[31m-[m[m
[31m-[31m-    # /api/v1/user 로 GET요청 받을 user list api (UserSerializer 사용)[m[m
[31m-[31m-    # http GET http://127.0.0.1:8000/api/v1/user "Authorization: Token 01ecad58c74bb6a6c52ab3f8cb6946cb7312e0d6"[m[m
[31m-[31m-    def list(self, request):[m[m
[31m-[31m-        # self.get_queryset() 이거로 queryset = User.objects.all() 이거 가져오는거임[m[m
[31m-[31m-        queryset = self.get_queryset()[m[m
[31m-[31m-        serializer = self.get_serializer(queryset, many=True)[m[m
[31m-[31m-        return Response(serializer.data)[m[m
[31m-[31m-[m[m
[31m-[31m-    # /api/v1/user/pk 로 GET요청 받을 user retrieve api (UserSerializer사용)[m[m
[31m-[31m-    # http GET http://127.0.0.1:8000/api/v1/user/48 "Authorization: Token 01ecad58c74bb6a6c52ab3f8cb6946cb7312e0d6"[m[m
[31m-[31m-    def retrieve(self, request, pk):[m[m
[31m-[31m-        # queryset과 pk값을 인자로 받아서,[m[m
[31m-[31m-        # queryset.filter(pk=pk)로 queryset을 뽑고,[m[m
[31m-[31m-        # instance = queryset.get()으로 객체만 뽑아서 리턴해 주는 메소드임[m[m
[31m-[31m-        # => 결국, 위 코드는 Customer.objects.get(pk=pk) 리턴함[m[m
[31m-[31m-        # https://velog.io/@jcinsh/RetrieveUpdateDestroyView-%EC%9D%B4%ED%95%B4 참조[m[m
[31m-[31m-        # queryset = User.objects.all() 이거를 기반으로 하는거임[m[m
[31m-[31m-        instance = self.get_object()[m[m
[31m-[31m-        serializer = self.get_serializer(instance)[m[m
[31m-[31m-        return Response(serializer.data)[m[m
[31m-[31m-[m[m
[31m-[31m-    # /api/v1/user/pk 로 PATCH 요청 받을 user update ap[m[m
[31m-[31m-    # http PUT http://127.0.0.1:8000/api/v1/user/50 "Authorization: Token 01ecad58c74bb6a6c52ab3f8cb6946cb7312e0d6"[m[m
[31m-[31m-    # 이거 비밀번호를 바꾸려면 userserilaier에서 비밀번호가 readonly여서 안보이니 비밀번호를 바꾸려면 serializer를 새로 만들어야함[m[m
[31m-[31m-    def update(self, request, pk):[m[m
[31m-[31m-        instance = self.get_object()[m[m
[31m-[31m-        # data앞에 뭐가 있으니 업데이트함[m[m
[31m-[31m-        serializer = self.get_serializer(instance, data=request.data, partial=True)[m[m
[31m-[31m-        try:[m[m
[31m-[31m-            serializer.is_valid(raise_exception=True)[m[m
[31m-[31m-            serializer.save()[m[m
[31m-[31m-            return Response(serializer.data)[m[m
[31m-[31m-        except serializers.ValidationError:[m[m
[31m-[31m-            return Response({"status": "failed", "errors": serializer.errors})[m[m
[31m-[31m-[m[m
[31m-[31m-    # /api/v1/user/pk 로 DELETE 요청 받을 user delete api (Serializer 사용 x)[m[m
[31m-[31m-    # http DELETE http://127.0.0.1:8000/api/v1/user/2000 "Authorization: Token 01ecad58c74bb6a6c52ab3f8cb6946cb7312e0d6"[m[m
[31m-[31m-    def delete(self, request, pk):[m[m
[31m-[31m-        print("in delete")[m[m
[31m-[31m-        instance = self.get_object()[m[m
[31m-[31m-        instance.delete()[m[m
[31m-[31m-        return Response({'success': True}, status=status.HTTP_204_NO_CONTENT)[m[m
[31m-[31m-[m[m
[31m-[31m-    # /api/v1/user 로 POST요청을 받을 registration api (UserSerializer 사용)[m[m
[31m-[31m-    # http POST http://127.0.0.1:8000/api/v1/user/register email="id@gmail.com" password="pw"[m[m
[31m-[31m-    @action(detail=False, methods=['post'], permission_classes=[AllowAny])[m[m
[31m-[31m-    def register(self, request):[m[m
[31m-[31m-        serializer = self.get_serializer(data=request.data)[m[m
[31m-[31m-        try:[m[m
[31m-[31m-            serializer.is_valid(raise_exception=True)[m[m
[31m-[31m-            # 이거 save()했을때 불려오는 method는[m[m
[31m-[31m-            # serializer = UserSerializer(data=request.data)에서 data앞에 뭐가 없으면[m[m
[31m-[31m-            # UserSerializer.create()를 불러오는거임[m[m
[31m-[31m-            serializer.save()[m[m
[31m-[31m-            # 이거 pw는 write_only라서 안보임[m[m
[31m-[31m-            print(serializer.data)[m[m
[31m-[31m-            return Response(serializer.data)[m[m
[31m-[31m-        except serializers.ValidationError:[m[m
[31m-[31m-            return Response({"status": "failed", "errors": serializer.errors})[m[m
[31m-[31m-[m[m
[31m-[31m-    # /api/v1/user/login 으로 POST요청을 받을 login api (LoginSerializer 사용)[m[m
[31m-[31m-    # http POST http://127.0.0.1:8000/api/v1/user/login email="id@gmail.com" password="pw"[m[m
[31m-[31m-    # 로그아웃 안하고 서버가 그냥 닫아지면 토큰 값이 유지되는거 같음 어떻게 해결해야함?[m[m
[31m-[31m-    # 이거 get_or_create로 하기때문에 같은거임 안그러면 서버껐다켰는데 애들다 토큰 날아가서 다 에러나거나 로그인페이지로 날아감[m[m
[31m-[31m-    # 해결하기 위해서는 토큰에 만료기한을 두고 토큰유출대도 credential이 없으면 만료시점이후에는 무효처리되도록 다시로그인시켜보는거지[m[m
[31m-[31m-    @action(detail=False, methods=['post'], permission_classes=[AllowAny])[m[m
[31m-[31m-    def login(self, request):[m[m
[31m-[31m-        serializer = LoginSerializer(data=request.data)[m[m
[31m-[31m-        try:[m[m
[31m-[31m-            serializer.is_valid(raise_exception=True)[m[m
[31m-[31m-            serializer.save()[m[m
[31m-[31m-            return Response(serializer.data)[m[m
[31m-[31m-        except InvalidPassword:[m[m
[31m-[31m-            return Response({'success': False, 'error': '패스워드가 일치하지 않습니다'}, status=status.HTTP_400_BAD_REQUEST)[m[m
[31m-[31m-        # 이거는 user = User.objects.get(email=email)에서 없으면 자동으로 raise됨[m[m
[31m-[31m-        except User.DoesNotExist:[m[m
[31m-[31m-            return Response({'success': False, 'error': '유저가 존재하지 않습니다'}, status=status.HTTP_400_BAD_REQUEST)[m[m
[31m-[31m-[m[m
[31m-[31m-    # /api/v1/user/logout 으로 DELETE 요청을 받을 logout api(Serializer 사용 x)[m[m
[31m-[31m-    # http POST http://127.0.0.1:8000/api/v1/user/logout "Authorization: Token f44c39fec18227d5aa555dcbd20aa7d56d0f55ef"[m[m
[31m-[31m-    @action(detail=False, methods=['post'], permission_classes=[IsAuthenticated])[m[m
[31m-[31m-    def logout(self, request):[m[m
[31m-[31m-        request.user.auth_token.delete()[m[m
[31m-[31m-[m[m
[31m-[31m-        return Response({'success': "로그아웃 성공"}, status=status.HTTP_200_OK)[m[m
[31m-[31m-    [m[m
[31m-[31m-    # 특정 유저가 publish 한 post 보기[m[m
[31m-[31m-[m[m
[31m- def post_list(request):[m[m
[31m-     # 쿼리를 만들어서 html로 보냄[m[m
[31m-     posts = Post.objects.filter(published_date__lte=timezone.now()).order_by('published_date')[m[m
[31m-[1mdiff --git a/industry_alert/db.sqlite3 b/industry_alert/db.sqlite3[m[m
[31m-[1mdeleted file mode 100644[m[m
[31m-[1mindex 501f3c2..0000000[m[m
[31m-Binary files a/industry_alert/db.sqlite3 and /dev/null differ[m
[31m-[1mdiff --git a/industry_alert/mysite/settings.py b/industry_alert/mysite/settings.py[m[m
[31m-[1mindex ff4f7da..b40da6c 100644[m[m
[31m-[1m--- a/industry_alert/mysite/settings.py[m[m
[31m-[1m+++ b/industry_alert/mysite/settings.py[m[m
[31m-[36m@@ -55,6 +55,7 @@[m [mINSTALLED_APPS = [[m[m
[31m-     'django.contrib.messages',[m[m
[31m-     'django.contrib.staticfiles',[m[m
[31m-     'blog', # blog 사용한다고 알려줘야함[m[m
[31m-[32m+[m[32m    'account',[m[m
[31m-     # drf login[m[m
[31m-     "rest_framework",[m[m
[31m-     "rest_framework.authtoken",[m[m
[31m-[1mdiff --git a/industry_alert/sqlite3.exe b/industry_alert/sqlite3.exe[m[m
[31m-[1mdeleted file mode 100644[m[m
[31m-[1mindex 4ad1ad4..0000000[m[m
[31m-Binary files a/industry_alert/sqlite3.exe and /dev/null differ[m
[1mdiff --git a/industry_alert/account/admin.py b/industry_alert/account/admin.py[m
[1mindex 8c38f3f..63417c4 100755[m
[1m--- a/industry_alert/account/admin.py[m
[1m+++ b/industry_alert/account/admin.py[m
[36m@@ -1,3 +1,5 @@[m
 from django.contrib import admin[m
[32m+[m[32mfrom .models import EveAccessToken[m
 [m
[31m-# Register your models here.[m
[32m+[m[32m# ModelAdmin class를 define하지 않으면 default admin interface가 제공됨[m
[32m+[m[32madmin.site.register(EveAccessToken)[m
[1mdiff --git a/industry_alert/account/migrations/0001_initial.py b/industry_alert/account/migrations/0001_initial.py[m
[1mindex 9896968..13ef5b7 100644[m
[1m--- a/industry_alert/account/migrations/0001_initial.py[m
[1m+++ b/industry_alert/account/migrations/0001_initial.py[m
[36m@@ -1,6 +1,9 @@[m
[31m-# Generated by Django 3.2.5 on 2021-11-06 10:28[m
[32m+[m[32m# Generated by Django 3.2.5 on 2021-11-23 09:11[m
 [m
[32m+[m[32mfrom django.conf import settings[m
 from django.db import migrations, models[m
[32m+[m[32mimport django.db.models.deletion[m
[32m+[m[32mimport django.utils.timezone[m
 [m
 [m
 class Migration(migrations.Migration):[m
[36m@@ -20,6 +23,7 @@[m [mclass Migration(migrations.Migration):[m
                 ('email', models.EmailField(default=None, max_length=60, unique=True, verbose_name='email')),[m
                 ('password', models.CharField(max_length=255, verbose_name='password')),[m
                 ('name', models.CharField(blank=True, default='', max_length=30, verbose_name='name')),[m
[32m+[m[32m                ('character_id', models.IntegerField(blank=True, default=0, verbose_name='character_id')),[m
                 ('is_admin', models.BooleanField(default=False)),[m
                 ('is_superuser', models.BooleanField(default=False)),[m
                 ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.Group', verbose_name='groups')),[m
[36m@@ -29,4 +33,15 @@[m [mclass Migration(migrations.Migration):[m
                 'abstract': False,[m
             },[m
         ),[m
[32m+[m[32m        migrations.CreateModel([m
[32m+[m[32m            name='EveAccessToken',[m
[32m+[m[32m            fields=[[m
[32m+[m[32m                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),[m
[32m+[m[32m                ('access_token', models.TextField()),[m
[32m+[m[32m                ('expires_in', models.DateTimeField(default=django.utils.timezone.now)),[m
[32m+[m[32m                ('token_type', models.CharField(max_length=255)),[m
[32m+[m[32m                ('refresh_token', models.CharField(max_length=255)),[m
[32m+[m[32m                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='eve_token', to=settings.AUTH_USER_MODEL)),[m
[32m+[m[32m            ],[m
[32m+[m[32m        ),[m
     ][m
[1mdiff --git a/industry_alert/account/models.py b/industry_alert/account/models.py[m
[1mindex ec96231..f56d1b3 100755[m
[1m--- a/industry_alert/account/models.py[m
[1m+++ b/industry_alert/account/models.py[m
[36m@@ -1,14 +1,28 @@[m
 from django.db import models[m
 from django.contrib.auth.base_user import BaseUserManager, AbstractBaseUser[m
 from django.contrib.auth.models import PermissionsMixin[m
[32m+[m[32mfrom django.conf import settings[m
[32m+[m[32mfrom django.db.models.fields import related[m
[32m+[m[32mfrom django.utils import timezone[m
 [m
 [m
[32m+[m[32mclass EveAccessToken(models.Model):[m
[32m+[m[32m    # fk 보다 one_to_one 사용[m
[32m+[m[32m    # one to many보다 one to one이 조인 비용 적음[m
[32m+[m[32m    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="eve_token")[m
[32m+[m[32m    # access_token jwt인데 이거 길이 상한이 없어서 char/varchar로 못하고 TextField로 해줘야함[m
[32m+[m[32m    access_token = models.TextField()[m
[32m+[m[32m    expires_in = models.DateTimeField(default=timezone.now)[m
[32m+[m[32m    token_type = models.CharField(max_length=255)[m
[32m+[m[32m    refresh_token = models.CharField(max_length=255)[m
[32m+[m
 # https://docs.djangoproject.com/en/3.2/ref/contrib/auth/[m
 class AccountManager(BaseUserManager):[m
     def create_user(self, email, password, name):[m
         if not email:[m
             raise ValueError('Users must have an email address')[m
[31m-        print('어카운트')[m
[32m+[m
[32m+[m
         # 이거 근데 꼭 해야하는건지는 모르겠음[m
         user = self.model([m
             # normalize_email()이거는 @domain에서 domain만 소문자로 만듬[m
[36m@@ -40,11 +54,15 @@[m [mclass AccountManager(BaseUserManager):[m
 # https://medium.com/geekculture/register-login-and-logout-users-in-django-rest-framework-51486390c29[m
 # https://github.com/django/django/blob/910ecd1b8df7678f45c3d507dde6bcb1faafa243/django/contrib/auth/base_user.py#L16 참조하기[m
 # 여기에 이름 생년월일 전화번호 같은 거 더 추가하기[m
[32m+[m
[32m+[m
[32m+[m[32m# 여기에다가 eve esi account id 추가해야함 그래야지 그거가지고 esi request함[m
 class User(AbstractBaseUser, PermissionsMixin):[m
     email = models.EmailField(verbose_name="email", max_length=60, unique=True, default=None)[m
     password = models.CharField(verbose_name='password', max_length=255)[m
     # charfield는 null true하는거아님 값이 비어있다를 표시하는게 빈스트링이랑 null 두가지가 다되면서 곱창남[m
     name = models.CharField(verbose_name='name', max_length=30, default='', blank=True)[m
[32m+[m[32m    character_id = models.IntegerField(verbose_name='character_id', default=0, blank=True)[m
     is_admin = models.BooleanField(default=False)[m
     is_superuser = models.BooleanField(default=False)[m
 [m
[36m@@ -62,4 +80,4 @@[m [mclass User(AbstractBaseUser, PermissionsMixin):[m
         return self.is_admin[m
 [m
     def __str__(self):[m
[31m-        return str(self.email)[m
\ No newline at end of file[m
[32m+[m[32m        return str(self.email)[m
[1mdiff --git a/industry_alert/account/serializers.py b/industry_alert/account/serializers.py[m
[1mindex 2d98842..83b0326 100644[m
[1m--- a/industry_alert/account/serializers.py[m
[1m+++ b/industry_alert/account/serializers.py[m
[36m@@ -1,5 +1,6 @@[m
[32m+[m[32mfrom requests.api import get[m
 from rest_framework import serializers[m
[31m-from .models import User[m
[32m+[m[32mfrom .models import User, EveAccessToken[m
 from django.contrib.auth import get_user_model[m
 from rest_framework.authtoken.models import Token[m
 # get_user_model() : 클래스이다.[m
[36m@@ -13,6 +14,48 @@[m [mfrom rest_framework.authtoken.models import Token[m
 # exceptions[m
 class InvalidPassword(Exception):[m
     pass[m
[32m+[m
[32m+[m[32m# class EsiIndustryJobs(serializers.ModelSerializer):[m
[32m+[m
[32m+[m[32m#     class Meta:[m
[32m+[m[32m#         model = IndustryJobs[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mclass EveUserSerializer(serializers.Serializer):[m
[32m+[m[32m    email = serializers.CharField(write_only=True)[m
[32m+[m[32m    name = serializers.CharField(write_only=True)[m
[32m+[m[32m    password = serializers.CharField(write_only=True)[m
[32m+[m[32m    character_id = serializers.IntegerField(write_only=True)[m
[32m+[m
[32m+[m[32m# https://stackoverflow.com/questions/42314882/drf-onetoonefield-create-serializer[m
[32m+[m[32mclass EveAccessTokenSerializer(serializers.Serializer):[m
[32m+[m[32m    # required=True는 default임[m
[32m+[m[32m    # 이거 돌려줄 필요없음[m
[32m+[m[32m    user = EveUserSerializer(write_only=True)[m
[32m+[m[32m    # 여기 token 넣어줘야지 create()에서 리턴해줄 수 있음 아니면 serialize를 못함[m
[32m+[m[32m    token = serializers.CharField(read_only=True)[m
[32m+[m[32m    created = serializers.BooleanField(read_only=True)[m
[32m+[m
[32m+[m[32m    class Meta:[m
[32m+[m[32m        model = EveAccessToken[m
[32m+[m[32m        fields = ['id', 'user', 'access_token', 'expires_in', 'token_type', 'refresh_token', 'token'][m
[32m+[m
[32m+[m[32m    def create(self, validated_data):[m
[32m+[m[32m        user_data = validated_data.pop('user')[m
[32m+[m[32m        print(user_data)[m
[32m+[m[32m        user_email = user_data.pop('email')[m
[32m+[m[32m        # 계정을 kwargs로 찾고 계정이 없으면 kwargs랑 defaults 둘 다 이용해서 생성해줌[m
[32m+[m[32m        user_instance, _= User.objects.get_or_create(email=user_email, defaults=user_data)[m
[32m+[m[32m        # 내 토큰 발급[m
[32m+[m[32m        token, _ = Token.objects.get_or_create(user=user_instance)[m
[32m+[m[32m        # EAT update하거나 생성[m
[32m+[m[32m        EveAccessToken.objects.update_or_create(user=user_instance, defaults=validated_data)[m
[32m+[m
[32m+[m[32m        # 여기서 return 하는 instance랑 시리얼라이저의 field를 기반으로 serializer.data가 만들어짐 여기서 튜플리턴하는데 없는것들 있어서 안가지는거임[m
[32m+[m[32m        #   return instance, user_instance, updated, 201, {"token": token.key}[m
[32m+[m[32m        return {"token": token.key}[m
[32m+[m
 # drf[m
 # 1. Serializer를 상속받은 LoginSerializer, 그리고 ModelSerializer를 상속받은 UserSerializer 두 개 작성[m
 # 2. 각 serializer는 아래와 같은 field를 가지고 이름에 맞는 동작을 해야함[m
[36m@@ -24,6 +67,7 @@[m [mclass InvalidPassword(Exception):[m
 class LoginSerializer(serializers.Serializer):[m
     # write_only는 값을 받아서 create/update같은거만 하는거임[m
     email = serializers.CharField(write_only=True)[m
[32m+[m[32m    # required=False[m
     password = serializers.CharField(write_only=True)[m
     # 입력받는게 아니라 return으로 돌려주는 값이니까 read_only임[m
     token = serializers.CharField(read_only=True)[m
[36m@@ -63,12 +107,12 @@[m [mclass LoginSerializer(serializers.Serializer):[m
 #     읽기전용 : token[m
 #     동작 : 받은 user정보를 통해 User를 생성하고, 생성된 user의 token을 새로 발행해서 password를 제외한 나머지 정보와 함께 돌려줌[m
 class UserSerializer(serializers.ModelSerializer):[m
[31m-    password = serializers.CharField(write_only=True)[m
[32m+[m[32m    password = serializers.CharField(write_only=True, required=False)[m
     token = serializers.CharField(read_only=True)[m
 [m
     class Meta:[m
         model = get_user_model()[m
[31m-        fields = ['email', 'password', 'name', 'token'][m
[32m+[m[32m        fields = ['email', 'password', 'name', 'character_id', 'token'][m
 [m
     # 이거 근데 user.mode()에서 해주는데 없어야하는거 같음[m
     # override하는거니까 인자 맞춰줘야함[m
[36m@@ -79,6 +123,7 @@[m [mclass UserSerializer(serializers.ModelSerializer):[m
         # **d means "take all additional named arguments to this function[m
         # and insert them into this parameter as dictionary entries."[m
         # 이거 create_user가 인자를 2개 받아야하니 **validated_data[m
[32m+[m[32m        print(validated_data)[m
         user = User.objects.create_user(**validated_data)[m
         # 가져오거나 생성한값이랑[m
         # 생성됐는지 가져온건지 여부를[m
[36m@@ -91,7 +136,8 @@[m [mclass UserSerializer(serializers.ModelSerializer):[m
         # 이렇게 하면 token이 추가가 가능한거임[m
         # 추가로 걍 객체를 serialize시키면 아까말한 __str__()값이 들어감[m
         user.token = token[m
[31m-        return user[m
[32m+[m[32m        # token object의 key가 사용하는 token임[m
[32m+[m[32m        return {"token": token.key}[m
 [m
     def update(self, instance, validated_data):[m
         # items()은 key, value 튜플쌍을 튜플로 리턴하는 함수임[m
[1mdiff --git a/industry_alert/account/tasks.py b/industry_alert/account/tasks.py[m
[1mnew file mode 100644[m
[1mindex 0000000..f346d33[m
[1m--- /dev/null[m
[1m+++ b/industry_alert/account/tasks.py[m
[36m@@ -0,0 +1,86 @@[m
[32m+[m[32m# Create your tasks here[m
[32m+[m[32mfrom celery import shared_task[m
[32m+[m[32mimport requests[m
[32m+[m[32mfrom esi.serializers import IndustryJobSerializer[m
[32m+[m[32mfrom esi.models import IndustryJob[m
[32m+[m[32mfrom .models import User[m
[32m+[m[32mfrom rest_framework import serializers[m
[32m+[m
[32m+[m
[32m+[m[32m# 주기적으로 task calling 하기[m
[32m+[m[32m@shared_task()[m
[32m+[m[32mdef temp_task(a, b):[m
[32m+[m[32m     return a + b[m
[32m+[m
[32m+[m[32m@shared_task()[m
[32m+[m[32mdef periodic_task1():[m
[32m+[m[32m     instance = User.objects.all()[m
[32m+[m
[32m+[m[32m     for user in instance:[m
[32m+[m[32m          # 이브를 통해서 생성된 계정이면[m
[32m+[m[32m          if user.character_id != 0:[m
[32m+[m[32m               pass[m
[32m+[m
[32m+[m
[32m+[m[32m# 갱신하는 토큰으로 새 토큰 받아옴[m
[32m+[m[32mdef get_new_accesstoken():[m
[32m+[m[32m     pass[m
[32m+[m
[32m+[m[32mdef esi_reqeust(character_id, access_token):[m
[32m+[m
[32m+[m[32m     acc = f'Bearer {access_token}'[m
[32m+[m[32m     # 처음에 가지고 있던 access token으로 시도 해봄[m
[32m+[m[32m     try:[m
[32m+[m[32m          url = f'https://esi.evetech.net/latest/characters/{str(character_id)}/industry/jobs/?datasource=tranquility'[m
[32m+[m[32m          res = requests.get([m
[32m+[m[32m               url,[m
[32m+[m[32m               headers={"Authorization": acc}[m
[32m+[m[32m          )[m
[32m+[m[32m          # 이거하면 리스트로옴[m
[32m+[m[32m          industry_jobs = res.json()[m
[32m+[m[32m          industry_job_status = industry_jobs[0]['status'][m
[32m+[m
[32m+[m[32m          return industry_jobs[m
[32m+[m[32m     # job이 없으면 task 종료[m
[32m+[m[32m     except IndexError:[m
[32m+[m[32m          return {"status": "there is no industry job"}[m
[32m+[m[32m     except KeyError:[m
[32m+[m[32m          return {"status": "faild to establish connection to eve server"}[m
[32m+[m[32m     except:[m
[32m+[m[32m          # 이게 만료된거면 refresh 해서 새로운거 가져와야함[m
[32m+[m[32m          pass[m
[32m+[m
[32m+[m
[32m+[m[32m# async task니까 리턴해줄 필요없음[m
[32m+[m[32m# 리턴하면 celery resutls에 저장됨[m
[32m+[m[32m@shared_task()[m
[32m+[m[32mdef get_industry_jobs(character_id, acc, eve_user_email):[m
[32m+[m[32m     # get access token from database[m
[32m+[m
[32m+[m[32m     # esi request[m
[32m+[m[32m     # acc가 만료되면 새로 받아오는 과정이 있어야해서 이거를 함수로 만들어야할거같음[m
[32m+[m[32m     try:[m
[32m+[m[32m          url = f'https://esi.evetech.net/latest/characters/{str(character_id)}/industry/jobs/?datasource=tranquility'[m
[32m+[m[32m          res = requests.get([m
[32m+[m[32m               url,[m
[32m+[m[32m               headers={"Authorization": acc}[m
[32m+[m[32m          )[m
[32m+[m[32m          # 이거하면 리스트로옴[m
[32m+[m[32m          industry_jobs = res.json()[m
[32m+[m[32m          industry_job_status = industry_jobs[0]['status'][m
[32m+[m[32m     # job이 없으면 task 종료[m
[32m+[m[32m     except IndexError:[m
[32m+[m[32m          return {"status": "there is no industry job"}[m
[32m+[m[32m     except KeyError:[m
[32m+[m[32m          return {"status": "faild to establish connection to eve server"}[m
[32m+[m
[32m+[m[32m     user = User.objects.get(email=eve_user_email)[m
[32m+[m[32m     # 잡 생성/업데이트[m
[32m+[m[32m     # many=true면 dict가 아닌 list를 넘겨야함[m
[32m+[m[32m     serializer = IndustryJobSerializer(data=industry_jobs, many=True, context={'user': user})[m
[32m+[m[32m     try:[m
[32m+[m[32m          serializer.is_valid(raise_exception=True)[m
[32m+[m[32m          serializer.save()[m
[32m+[m[32m     except serializers.ValidationError:[m
[32m+[m[32m          return {"status": "failed", "errors": serializer.errors}[m
[32m+[m[32m     return serializer.data[m
[1mdiff --git a/industry_alert/account/urls.py b/industry_alert/account/urls.py[m
[1mindex f630833..e196818 100644[m
[1m--- a/industry_alert/account/urls.py[m
[1m+++ b/industry_alert/account/urls.py[m
[36m@@ -8,6 +8,7 @@[m [mfrom rest_framework.routers import DefaultRouter[m
 [m
 router = DefaultRouter(trailing_slash=False)[m
 router.register(r'user', views.AccountViewSet, basename='logins')[m
[32m+[m[32mrouter.register(r'evelogin', views.EveLoginViewSet, basename='evelogins')[m
 [m
 urlpatterns = [[m
     path('api/v1/', include(router.urls)),[m
[1mdiff --git a/industry_alert/account/utils.py b/industry_alert/account/utils.py[m
[1mnew file mode 100644[m
[1mindex 0000000..43499ac[m
[1m--- /dev/null[m
[1m+++ b/industry_alert/account/utils.py[m
[36m@@ -0,0 +1,32 @@[m
[32m+[m[32m# for random passowrd[m
[32m+[m[32mimport string[m
[32m+[m[32mimport secrets[m
[32m+[m[41m [m
[32m+[m[32m # create url for esi request[m
[32m+[m[32mdef url_creator(character_id, scopes):[m
[32m+[m[32m    base_url = 'https://esi.evetech.net/latest/characters/'[m
[32m+[m
[32m+[m[32m    # 이거 뒤에 query string 떼내야함[m
[32m+[m[32m    esi_scopes = {'industry_jobs': '/industry/jobs/?datasource=tranquility'}[m
[32m+[m
[32m+[m[32m    return base_url + str(character_id) + esi_scopes[scopes][m
[32m+[m[41m    [m
[32m+[m[32mdef email_creator(character_name):[m
[32m+[m[32m    domain = '@eveoline.com'[m
[32m+[m[32m    character_name.replace(" ", "")[m
[32m+[m
[32m+[m[32m    return character_name + domain[m
[32m+[m
[32m+[m[32mdef create_random_string():[m
[32m+[m[32m    alphabet = string.ascii_letters + string.digits[m
[32m+[m[32m    while True:[m
[32m+[m[32m        # 알파벳 소문자 5개 이상[m
[32m+[m[32m        # 알파벳 대문자 5개 이상[m
[32m+[m[32m        # 숫자 3개 이상[m
[32m+[m[32m        password = ''.join(secrets.choice(alphabet) for i in range(20))[m
[32m+[m[32m        if (sum(c.islower() for c in password) >=5[m
[32m+[m[32m            and sum(c.isupper() for c in password) >= 5[m
[32m+[m[32m            and sum(c.isdigit() for c in password) >= 3):[m
[32m+[m[32m            break[m
[32m+[m
[32m+[m[32m    return password[m
\ No newline at end of file[m
[1mdiff --git a/industry_alert/account/views.py b/industry_alert/account/views.py[m
[1mindex 37c670b..f7651b5 100755[m
[1m--- a/industry_alert/account/views.py[m
[1m+++ b/industry_alert/account/views.py[m
[36m@@ -3,8 +3,126 @@[m [mfrom rest_framework.decorators import action[m
 from rest_framework.response import Response[m
 from rest_framework.permissions import AllowAny, IsAuthenticated[m
 from rest_framework.authtoken.models import Token[m
[31m-from .models import User[m
[31m-from .serializers import LoginSerializer, UserSerializer, InvalidPassword[m
[32m+[m[32mfrom .models import EveAccessToken, User[m
[32m+[m[32mfrom .serializers import LoginSerializer, UserSerializer, EveUserSerializer, EveAccessTokenSerializer, InvalidPassword[m
[32m+[m
[32m+[m[32m# eve login[m
[32m+[m[32mimport requests[m
[32m+[m[32mimport base64[m
[32m+[m[32mimport os[m
[32m+[m[32mfrom dotenv import load_dotenv[m
[32m+[m[32mfrom .utils import url_creator, email_creator, create_random_string[m
[32m+[m
[32m+[m[32m# eve access token[m
[32m+[m[32mimport datetime[m
[32m+[m
[32m+[m[32m# celery task[m
[32m+[m[32mfrom .tasks import get_industry_jobs[m
[32m+[m
[32m+[m[32m# 이브 로그인 관련[m
[32m+[m[32mclass EveLoginViewSet(viewsets.GenericViewSet):[m
[32m+[m[32m    permission_classes = [AllowAny][m
[32m+[m[32m    queryset = User.objects.all()[m
[32m+[m[32m    serializer_class = EveUserSerializer[m
[32m+[m
[32m+[m[32m    @action(methods=['get'], detail=False)[m
[32m+[m[32m    def callback(self, request):[m
[32m+[m[32m        # get()[m
[32m+[m[32m        # Returns the value for key in the dictionary; if not found returns a default value.[m
[32m+[m[32m        # Optional.[m[41m [m
[32m+[m[32m        # Value that is returned when the key is not found. Defaults to None, so that this method never raises a KeyError.[m
[32m+[m[41m        [m
[32m+[m[32m        # 저쪽에서 이쪽으로 request 보낸거는 정상으로 간주하고 해야함[m
[32m+[m[32m        auth_code = request.GET.get('code')[m
[32m+[m[32m        state = request.GET.get('state')[m
[32m+[m
[32m+[m[32m        # Now that your application has the authorization code,[m[41m [m
[32m+[m[32m        # it needs to send a POST request to[m
[32m+[m[32m        # https://login.eveonline.com/v2/oauth/token[m
[32m+[m[32m        # where your application’s client ID will be the user[m
[32m+[m[32m        #  your secret key will be the password[m
[32m+[m[32m        load_dotenv()[m
[32m+[m[32m        client_id = os.getenv('ID')[m
[32m+[m[32m        secret_key = os.getenv('KEY')[m
[32m+[m
[32m+[m[32m        # You will need to send the following HTTP headers (replace anything between <>, including <>)[m
[32m+[m[32m        # Authorization: Basic <URL safe Base64 encoded credentials>[m
[32m+[m[32m        # Content-Type: application/x-www-form-urlencoded[m
[32m+[m[32m        # Host: login.eveonline.com[m
[32m+[m[32m        user_pass = f'{client_id}:{secret_key}'[m
[32m+[m[32m        basic_auth = base64.urlsafe_b64encode(user_pass.encode()).decode()[m
[32m+[m[32m        auth_header = f'Basic {basic_auth}'[m
[32m+[m
[32m+[m[32m        headers = {[m
[32m+[m[32m            "Authorization": auth_header,[m
[32m+[m[32m            "Content-Type": "application/x-www-form-urlencoded",[m
[32m+[m[32m            "Host": "login.eveonline.com",[m
[32m+[m[32m        }[m
[32m+[m[32m        body = {[m
[32m+[m[32m            'grant_type': 'authorization_code',[m
[32m+[m[32m            'code': auth_code[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        # Finally, send a POST request to https://login.eveonline.com/v2/oauth/token with your form encoded values and the headers from the last step.[m
[32m+[m[32m        try:[m
[32m+[m[32m            res = requests.post([m
[32m+[m[32m                'https://login.eveonline.com/v2/oauth/token',[m
[32m+[m[32m                headers=headers,[m
[32m+[m[32m                data=body[m
[32m+[m[32m            )[m
[32m+[m[32m            # If the previous step was done correctly, the EVE SSO will respond with a JSON payload containing an access token (which is a Json Web Token)[m[41m [m
[32m+[m[32m            # and a refresh token that looks like this (Anything wrapped by <> will look different for you):[m
[32m+[m[32m            res_dict = res.json()[m
[32m+[m[32m            # access_token = res_dict.get('access_token')[m
[32m+[m[32m            # get()은 default를 return 하니때문에 keyerror생성안하니 get()이거 쓰면 안됨[m
[32m+[m[32m            access_token = res_dict['access_token'][m
[32m+[m[32m            res_dict['expires_in'] = datetime.datetime.now() + datetime.timedelta(minutes=19, seconds=59)[m
[32m+[m[32m            # 이거 어차피 여기서 access_token이 안온거면 연결이  실패한거임[m
[32m+[m[32m            # 그러니까 예외는 여기서 keyError하나만 잡고 나머지 다른 에러는[m
[32m+[m[32m            # django에서 500에러 주니 이거 logging 해서 잡아내면됨[m
[32m+[m[32m            # 클라이언트는 잡다한 예외 상황 알 필요없고 여기 기준으로는 이브와의 서버 통신을 실패한거만 알면 되기 떄문에[m
[32m+[m[32m            # 그냥 access_token 없으면 이브 서버와의 통신이 실패한거니 실패했다고 알려주면됨.[m
[32m+[m[32m        except KeyError:[m
[32m+[m[32m            return Response({"status": "failed", "errors": "이브서버와 통신을 실패했습니다."})[m
[32m+[m
[32m+[m[32m        # 여기서 말하는 JSON payload가 위의 res에 저장됨[m
[32m+[m
[32m+[m[32m        # access_token으로 eve character name 가져옴[m
[32m+[m[32m        acc = f'Bearer {access_token}'[m
[32m+[m[32m        try:[m
[32m+[m[32m            character_res = requests.get([m
[32m+[m[32m                "https://login.eveonline.com/oauth/verify",[m
[32m+[m[32m                headers={"Authorization": acc}[m
[32m+[m[32m            )[m
[32m+[m[32m            character_dict = character_res.json()[m
[32m+[m[32m            character_id = character_dict['CharacterID'][m
[32m+[m[32m        except KeyError:[m
[32m+[m[32m            return Response({"status": "failed", "errors": "이브서버와 통신을 실패했습니다."})[m
[32m+[m
[32m+[m[32m        # create django user and return its token[m
[32m+[m[32m        # eve_user = {} 이렇게 하는거보다 {}이 set, dictionary 둘 다여서 dict()해주는게 좋음[m
[32m+[m[32m        eve_user = dict()[m
[32m+[m[32m        eve_user_email = email_creator(character_dict['CharacterName'])[m
[32m+[m[32m        eve_user['email'] = eve_user_email[m
[32m+[m[32m        eve_user['name'] = character_dict['CharacterName'][m
[32m+[m[32m        eve_user['password'] = create_random_string()[m
[32m+[m[32m        eve_user['character_id'] = character_id[m
[32m+[m
[32m+[m[32m        temp_dict = res_dict.copy()[m
[32m+[m[32m        temp_dict['user'] = eve_user[m
[32m+[m
[32m+[m[32m        # EveAccessToken 저장[m
[32m+[m[32m        serializer = EveAccessTokenSerializer(data=temp_dict)[m
[32m+[m[32m        try:[m
[32m+[m[32m            serializer.is_valid(raise_exception=True)[m
[32m+[m[32m            serializer.save()[m
[32m+[m
[32m+[m[32m            # celery로 job 받아오기[m
[32m+[m[32m            get_industry_jobs.delay(character_id, acc, eve_user_email)[m
[32m+[m[32m            return Response(serializer.data, status=status.HTTP_201_CREATED)[m
[32m+[m
[32m+[m[32m        except serializers.ValidationError:[m
[32m+[m[32m            return Response({"status": "failed login user via eve account", "errors": serializer.errors})[m
 [m
 # drf login[m
 # https://stackoverflow.com/questions/26906630/django-rest-framework-authentication-credentials-were-not-provided 이거 지금 해결안되고있음[m
[36m@@ -78,19 +196,36 @@[m [mclass AccountViewSet(viewsets.GenericViewSet):[m
     # /api/v1/user 로 POST요청을 받을 registration api (UserSerializer 사용)[m
     # http POST http://127.0.0.1:8000/api/v1/user/register email="id@gmail.com" password="pw"[m
     @action(detail=False, methods=['post'], permission_classes=[AllowAny])[m
[31m-    def register(self, request):[m
[31m-        serializer = self.get_serializer(data=request.data)[m
[31m-        try:[m
[31m-            serializer.is_valid(raise_exception=True)[m
[31m-            # 이거 save()했을때 불려오는 method는[m
[31m-            # serializer = UserSerializer(data=request.data)에서 data앞에 뭐가 없으면[m
[31m-            # UserSerializer.create()를 불러오는거임[m
[31m-            serializer.save()[m
[31m-            # 이거 pw는 write_only라서 안보임[m
[31m-            print(serializer.data)[m
[31m-            return Response(serializer.data)[m
[31m-        except serializers.ValidationError:[m
[31m-            return Response({"status": "failed", "errors": serializer.errors})[m
[32m+[m[32m    def register(self, request, eve_user=None):[m
[32m+[m[32m        print("in register")[m
[32m+[m[32m        print(eve_user)[m
[32m+[m[32m        if eve_user:[m
[32m+[m[32m            serializer = self.get_serializer(data=eve_user)[m
[32m+[m[32m            try:[m
[32m+[m[32m                serializer.is_valid(raise_exception=True)[m
[32m+[m[32m                # 이거 save()했을때 불려오는 method는[m
[32m+[m[32m                # serializer = UserSerializer(data=request.data)에서 data앞에 뭐가 없으면[m
[32m+[m[32m                # UserSerializer.create()를 불러오는거임[m
[32m+[m[32m                serializer.save()[m
[32m+[m[32m                # 이거 pw는 write_only라서 안보임[m
[32m+[m[32m                print("in register2")[m
[32m+[m[32m                print(serializer.data)[m
[32m+[m[32m                return Response(serializer.data)[m
[32m+[m[32m            except serializers.ValidationError:[m
[32m+[m[32m                return Response({"status": "failed", "errors": serializer.errors})[m
[32m+[m[32m        else:[m[41m [m
[32m+[m[32m            serializer = self.get_serializer(data=request.data)[m
[32m+[m[32m            try:[m
[32m+[m[32m                serializer.is_valid(raise_exception=True)[m
[32m+[m[32m                # 이거 save()했을때 불려오는 method는[m
[32m+[m[32m                # serializer = UserSerializer(data=request.data)에서 data앞에 뭐가 없으면[m
[32m+[m[32m                # UserSerializer.create()를 불러오는거임[m
[32m+[m[32m                serializer.save()[m
[32m+[m[32m                # 이거 pw는 write_only라서 안보임[m
[32m+[m[32m                print(serializer.data)[m
[32m+[m[32m                return Response(serializer.data)[m
[32m+[m[32m            except serializers.ValidationError:[m
[32m+[m[32m                return Response({"status": "failed", "errors": serializer.errors})[m
 [m
     # /api/v1/user/login 으로 POST요청을 받을 login api (LoginSerializer 사용)[m
     # http POST http://127.0.0.1:8000/api/v1/user/login email="id@gmail.com" password="pw"[m
[36m@@ -118,4 +253,4 @@[m [mclass AccountViewSet(viewsets.GenericViewSet):[m
 [m
         return Response({'success': "로그아웃 성공"}, status=status.HTTP_200_OK)[m
 [m
[31m-    # 특정 유저가 publish 한 post 보기[m
\ No newline at end of file[m
[32m+[m[32m    # 특정 유저가 publish 한 post 보기[m
[1mdiff --git a/industry_alert/blog/migrations/0001_initial.py b/industry_alert/blog/migrations/0001_initial.py[m
[1mindex 80415cd..3f4f55d 100644[m
[1m--- a/industry_alert/blog/migrations/0001_initial.py[m
[1m+++ b/industry_alert/blog/migrations/0001_initial.py[m
[36m@@ -1,4 +1,4 @@[m
[31m-# Generated by Django 3.2.5 on 2021-11-06 10:28[m
[32m+[m[32m# Generated by Django 3.2.5 on 2021-11-23 09:11[m
 [m
 import blog.models[m
 from django.conf import settings[m
[1mdiff --git a/industry_alert/blog/serializers.py b/industry_alert/blog/serializers.py[m
[1mindex 4e4277e..98b58f3 100644[m
[1m--- a/industry_alert/blog/serializers.py[m
[1m+++ b/industry_alert/blog/serializers.py[m
[36m@@ -61,13 +61,14 @@[m [mclass CommentSerializer(serializers.ModelSerializer):[m
     # 이 related field들이 fk constraint말고도 실제로 칼럼이름이 post_id로 저장되어 있음[m
     # post_id같이 (related_field이름)_id 이런식으로 실제 db에 기록대고[m
     # 이게 본체인거고 저런 post 같은게 장고가 알아서 해주는 부분인데[m
[32m+[m[32m    # 밑에 이거 없어도되는거같은데 물어보기[m
     post_id = serializers.PrimaryKeyRelatedField(queryset=Post.objects.all(), required=False)[m
 [m
     class Meta:[m
         model = Comment[m
         fields = ['id', 'post_id', 'author', 'text', 'created_date', 'approved_comment'][m
 [m
[31m-    #  is_valid가 3가지 검사를 함[m
[32m+[m[32m    # is_valid가 3가지 검사를 함[m
     # model에 정의된거랑 타입이 맞는지 필드별로 검사 한 번 다 하고[m
     # serializer에 validate_필드이름 이렇게 정의한 함스들 코드에서 파싱해서 저 함수들 한번씩 다 돌려주고[m
     # 각 필드에 대한 추가적인 validation임[m
[1mdiff --git a/industry_alert/blog/urls.py b/industry_alert/blog/urls.py[m
[1mindex 51b14b4..c0d6470 100644[m
[1m--- a/industry_alert/blog/urls.py[m
[1m+++ b/industry_alert/blog/urls.py[m
[36m@@ -16,7 +16,6 @@[m [mrouter = DefaultRouter(trailing_slash=False)[m
 # create api는 post-create[m
 router.register(r'post', views.PostViewSet2, basename='posts')[m
 router.register(r'comment', views.CommentViewSet, basename='comments')[m
[31m-router.register(r'evelogin', views.EveLoginViewSet, basename='evelogins')[m
 [m
 urlpatterns = [[m
 	# YOUR PATTERNS[m
[1mdiff --git a/industry_alert/blog/views.py b/industry_alert/blog/views.py[m
[1mindex 5397489..3450358 100644[m
[1m--- a/industry_alert/blog/views.py[m
[1m+++ b/industry_alert/blog/views.py[m
[36m@@ -33,121 +33,6 @@[m [mfrom .models import EntryImage[m
 from .serializers import ImageSerializer[m
 from django.contrib.contenttypes.models import ContentType[m
 [m
[31m-# eve login[m
[31m-import requests[m
[31m-import base64[m
[31m-from dotenv import load_dotenv[m
[31m-import os[m
[31m-# 이브 로그인 관련[m
[31m-class EveLoginViewSet(viewsets.GenericViewSet):[m
[31m-    permission_classes = [AllowAny][m
[31m-[m
[31m-    # create url for esi request[m
[31m-    def url_creater(self, character_id, scopes):[m
[31m-        base_url = 'https://esi.evetech.net/latest/characters/'[m
[31m-[m
[31m-        # 이거 뒤에 query string 떼내야함[m
[31m-        esi_scopes = {'industry_jobs': '/industry/jobs/?datasource=tranquility'}[m
[31m-[m
[31m-        return base_url + str(character_id) + esi_scopes[scopes][m
[31m-[m
[31m-    @action(methods=['get'], detail=False, url_path='redirect')[m
[31m-    def get_users_published_posts(self, request):[m
[31m-        print(count_widgets.delay())[m
[31m-        # 이거 state는 원래 random한  스트링 넣어야하는데 지금은 그냥 걍함[m
[31m-        return redirect('https://login.eveonline.com/v2/oauth/authorize/? \[m
[31m-                         response_type=code \[m
[31m-                         & \[m
[31m-                         redirect_uri=http%3A%2F%2F13.124.169.90%3A8000%2Fapi%2Fv1%2Fevelogin%2Fcallback \[m
[31m-                         & \[m
[31m-                         client_id=8e86edc0f4ee45b6a5f70cdba2f01ea7 \[m
[31m-                         & \[m
[31m-                         scope=esi-industry.read_character_jobs.v1 \[m
[31m-                         & \[m
[31m-                         state=3sooham')[m
[31m-[m
[31m-    @action(methods=['get'], detail=False)[m
[31m-    def callback(self, request):[m
[31m-        # get()[m
[31m-        # Returns the value for key in the dictionary; if not found returns a default value.[m
[31m-        # Optional. [m
[31m-        # Value that is returned when the key is not found. Defaults to None, so that this method never raises a KeyError.[m
[31m-        [m
[31m-        # 저쪽에서 이쪽으로 request 보낸거는 정상으로 간주하고 해야함[m
[31m-        auth_code = request.GET.get('code')[m
[31m-        state = request.GET.get('state')[m
[31m-[m
[31m-        # Now that your application has the authorization code, [m
[31m-        # it needs to send a POST request to[m
[31m-        # https://login.eveonline.com/v2/oauth/token[m
[31m-        # where your application’s client ID will be the user[m
[31m-        #  your secret key will be the password[m
[31m-        load_dotenv()[m
[31m-        client_id = os.getenv('ID')[m
[31m-        secret_key = os.getenv('KEY')[m
[31m-[m
[31m-        # You will need to send the following HTTP headers (replace anything between <>, including <>)[m
[31m-        # Authorization: Basic <URL safe Base64 encoded credentials>[m
[31m-        # Content-Type: application/x-www-form-urlencoded[m
[31m-        # Host: login.eveonline.com[m
[31m-        user_pass = f'{client_id}:{secret_key}'[m
[31m-        basic_auth = base64.urlsafe_b64encode(user_pass.encode()).decode()[m
[31m-        auth_header = f'Basic {basic_auth}'[m
[31m-[m
[31m-        headers = {[m
[31m-            "Authorization": auth_header,[m
[31m-            "Content-Type": "application/x-www-form-urlencoded",[m
[31m-            "Host": "login.eveonline.com",[m
[31m-        }[m
[31m-        body = {[m
[31m-            'grant_type': 'authorization_code',[m
[31m-            'code': auth_code[m
[31m-        }[m
[31m-[m
[31m-        # Finally, send a POST request to https://login.eveonline.com/v2/oauth/token with your form encoded values and the headers from the last step.[m
[31m-        try:[m
[31m-            res = requests.post([m
[31m-                'https://login.eveonline.com/v2/oauth/token',[m
[31m-                headers=headers,[m
[31m-                data=body[m
[31m-            )[m
[31m-            res_dict = res.json()[m
[31m-            access_token = res_dict.get('access_token')[m
[31m-            # 이거 어차피 여기서 access_token이 안온거면 연결이  실패한거임[m
[31m-            # 그러니까 예외는 여기서 keyError하나만 잡고 나머지 다른 에러는[m
[31m-            # django에서 500에러 주니 이거 logging 해서 잡아내면됨[m
[31m-            # 클라이언트는 잡다한 예외 상황 알 필요없고 여기 기준으로는 이브와의 서버 통신을 실패한거만 알면 되기 떄문에[m
[31m-            # 그냥 access_token 없으면 이브 서버와의 통신이 실패한거니 실패했다고 알려주면됨.[m
[31m-        except KeyError:[m
[31m-            return Response({"status": "failed", "errors": "이브서버와 통신을 실패했습니다."})[m
[31m-[m
[31m-        # If the previous step was done correctly, the EVE SSO will respond with a JSON payload containing an access token (which is a Json Web Token) [m
[31m-        # and a refresh token that looks like this (Anything wrapped by <> will look different for you):[m
[31m-        # 여기서 말하는 JSON payload가 위의 res에 저장됨[m
[31m-        acc = 'Bearer ' + access_token[m
[31m-        try:[m
[31m-            character_res = requests.get([m
[31m-                "https://login.eveonline.com/oauth/verify",[m
[31m-                headers={"Authorization": acc}[m
[31m-            )[m
[31m-            character_dict = character_res.json()[m
[31m-            character_id = character_dict['CharacterID'][m
[31m-        except KeyError:[m
[31m-            return Response({"status": "failed", "errors": "이브서버와 통신을 실패했습니다."})[m
[31m-[m
[31m-        esi_request_url = self.url_creater(character_id, 'industry_jobs')[m
[31m-        [m
[31m-        res4 = requests.get([m
[31m-             esi_request_url,[m
[31m-             headers= {'Authorization': acc}[m
[31m-        )[m
[31m-[m
[31m-        dd = res4.json()[m
[31m-[m
[31m-        # create django user and return its token[m
[31m-[m
[31m-        return Response({"너는": dd})[m
[31m-[m
 # drf viewset[m
 class PostViewSet(viewsets.ModelViewSet):[m
     queryset = Post.objects.all()[m
[36m@@ -211,7 +96,7 @@[m [mclass PostViewSet2(viewsets.GenericViewSet):[m
     def add_image(self, instance, request):[m
         try:[m
             #  fields = ['id', 'image', 'content_type', 'object_id'][m
[31m-            import pdb; pdb.set_trace()[m
[32m+[m[32m            # import pdb; pdb.set_trace()[m
             # verbose_name 옵션을 지정하지 않으면 CamelCase 클래스 이름을 기준으로 camel case 이와 같이 모두 소문자로 변경한다.[m
             # https://wikidocs.net/6667#verbose_name[m
             # user_type = ContentType.objects.get(app_label='blog', model='post')[m
[1mdiff --git a/industry_alert/esi/__init__.py b/industry_alert/esi/__init__.py[m
[1mnew file mode 100644[m
[1mindex 0000000..e69de29[m
[1mdiff --git a/industry_alert/esi/admin.py b/industry_alert/esi/admin.py[m
[1mnew file mode 100644[m
[1mindex 0000000..4e3e4a2[m
[1m--- /dev/null[m
[1m+++ b/industry_alert/esi/admin.py[m
[36m@@ -0,0 +1,5 @@[m
[32m+[m[32mfrom django.contrib import admin[m
[32m+[m[32mfrom .models import IndustryJob[m
[32m+[m[32m# Register your models here.[m
[32m+[m
[32m+[m[32madmin.site.register(IndustryJob)[m
[1mdiff --git a/industry_alert/esi/apps.py b/industry_alert/esi/apps.py[m
[1mnew file mode 100644[m
[1mindex 0000000..051dafd[m
[1m--- /dev/null[m
[1m+++ b/industry_alert/esi/apps.py[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32mfrom django.apps import AppConfig[m
[32m+[m
[32m+[m
[32m+[m[32mclass EsiConfig(AppConfig):[m
[32m+[m[32m    default_auto_field = 'django.db.models.BigAutoField'[m
[32m+[m[32m    name = 'esi'[m
[1mdiff --git a/industry_alert/esi/migrations/0001_initial.py b/industry_alert/esi/migrations/0001_initial.py[m
[1mnew file mode 100644[m
[1mindex 0000000..8be7a29[m
[1m--- /dev/null[m
[1m+++ b/industry_alert/esi/migrations/0001_initial.py[m
[36m@@ -0,0 +1,46 @@[m
[32m+[m[32m# Generated by Django 3.2.5 on 2021-11-23 09:11[m
[32m+[m
[32m+[m[32mfrom django.conf import settings[m
[32m+[m[32mfrom django.db import migrations, models[m
[32m+[m[32mimport django.db.models.deletion[m
[32m+[m
[32m+[m
[32m+[m[32mclass Migration(migrations.Migration):[m
[32m+[m
[32m+[m[32m    initial = True[m
[32m+[m
[32m+[m[32m    dependencies = [[m
[32m+[m[32m        migrations.swappable_dependency(settings.AUTH_USER_MODEL),[m
[32m+[m[32m    ][m
[32m+[m
[32m+[m[32m    operations = [[m
[32m+[m[32m        migrations.CreateModel([m
[32m+[m[32m            name='IndustryJob',[m
[32m+[m[32m            fields=[[m
[32m+[m[32m                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),[m
[32m+[m[32m                ('activity_id', models.IntegerField(null=True)),[m
[32m+[m[32m                ('blueprint_id', models.BigIntegerField(null=True)),[m
[32m+[m[32m                ('blueprint_location_id', models.BigIntegerField(null=True)),[m
[32m+[m[32m                ('blueprint_type_id', models.BigIntegerField(null=True)),[m
[32m+[m[32m                ('completed_character_id', models.IntegerField(null=True)),[m
[32m+[m[32m                ('completed_data', models.DateTimeField(null=True)),[m
[32m+[m[32m                ('cost', models.DecimalField(decimal_places=4, max_digits=13, null=True)),[m
[32m+[m[32m                ('duration', models.IntegerField(null=True)),[m
[32m+[m[32m                ('end_date', models.DateTimeField(null=True)),[m
[32m+[m[32m                ('facility_id', models.BigIntegerField(null=True)),[m
[32m+[m[32m                ('installer_id', models.IntegerField(null=True)),[m
[32m+[m[32m                ('job_id', models.IntegerField(null=True)),[m
[32m+[m[32m                ('licensed_runs', models.IntegerField(null=True)),[m
[32m+[m[32m                ('output_location_id', models.BigIntegerField(null=True)),[m
[32m+[m[32m                ('pause_date', models.DateTimeField(null=True)),[m
[32m+[m[32m                ('probability', models.FloatField(null=True)),[m
[32m+[m[32m                ('product_type_id', models.IntegerField(null=True)),[m
[32m+[m[32m                ('runs', models.IntegerField(null=True)),[m
[32m+[m[32m                ('start_date', models.DateTimeField(null=True)),[m
[32m+[m[32m                ('station_id', models.BigIntegerField(null=True)),[m
[32m+[m[32m                ('status', models.CharField(choices=[('active', 'Active'), ('cancelled', 'Cancelled'), ('delivered', 'Delivered'), ('paused', 'Paused'), ('ready', 'Ready'), ('reverted', 'Reverted')], max_length=10)),[m
[32m+[m[32m                ('successful_runs', models.IntegerField(null=True)),[m
[32m+[m[32m                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='indsutry_jobs', to=settings.AUTH_USER_MODEL)),[m
[32m+[m[32m            ],[m
[32m+[m[32m        ),[m
[32m+[m[32m    ][m
[1mdiff --git a/industry_alert/esi/migrations/__init__.py b/industry_alert/esi/migrations/__init__.py[m
[1mnew file mode 100644[m
[1mindex 0000000..e69de29[m
[1mdiff --git a/industry_alert/esi/models.py b/industry_alert/esi/models.py[m
[1mnew file mode 100644[m
[1mindex 0000000..2892a80[m
[1m--- /dev/null[m
[1m+++ b/industry_alert/esi/models.py[m
[36m@@ -0,0 +1,78 @@[m
[32m+[m[32mfrom django.db import models[m
[32m+[m[32mfrom django.conf import settings[m
[32m+[m[32mfrom django.utils.translation import gettext_lazy as _[m
[32m+[m
[32m+[m[32m# 클래스명 단수로[m
[32m+[m[32m# 이름 붙이는 거는 불려오는곳에서 이름이 얼마나 자연스러운지가 중요함[m
[32m+[m[32mclass IndustryJob(models.Model):[m
[32m+[m[32m    class Status(models.TextChoices):[m
[32m+[m[32m        ACTIVE = 'active', _('Active'),[m
[32m+[m[32m        CANCELLED = 'cancelled', _('Cancelled'),[m
[32m+[m[32m        DELIVERED = 'delivered', _('Delivered'),[m
[32m+[m[32m        PAUSED = 'paused', _('Paused'),[m
[32m+[m[32m        READY = 'ready', _('Ready'),[m
[32m+[m[32m        REVERTED = 'reverted', _('Reverted')[m
[32m+[m
[32m+[m[32m    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="indsutry_jobs")[m
[32m+[m[32m    activity_id = models.IntegerField(null=True)[m
[32m+[m[32m    blueprint_id = models.BigIntegerField(null=True)[m
[32m+[m[32m    blueprint_location_id = models.BigIntegerField(null=True)[m
[32m+[m[32m    blueprint_type_id = models.BigIntegerField(null=True)[m
[32m+[m[32m    completed_character_id = models.IntegerField(null=True)[m
[32m+[m[32m    completed_data = models.DateTimeField(null=True)[m
[32m+[m[32m    cost = models.DecimalField(max_digits=13, decimal_places=4, null=True)[m
[32m+[m[32m    duration = models.IntegerField(null=True)[m
[32m+[m[32m    end_date = models.DateTimeField(null=True)[m
[32m+[m[32m    facility_id = models.BigIntegerField(null=True)[m
[32m+[m[32m    installer_id = models.IntegerField(null=True)[m
[32m+[m[32m    job_id = models.IntegerField(null=True)[m
[32m+[m[32m    licensed_runs = models.IntegerField(null=True)[m
[32m+[m[32m    output_location_id = models.BigIntegerField(null=True)[m
[32m+[m[32m    pause_date = models.DateTimeField(null=True)[m
[32m+[m[32m    probability = models.FloatField(null=True)[m
[32m+[m[32m    product_type_id = models.IntegerField(null=True)[m
[32m+[m[32m    runs = models.IntegerField(null=True)[m
[32m+[m[32m    start_date = models.DateTimeField(null=True)[m
[32m+[m[32m    station_id = models.BigIntegerField(null=True)[m
[32m+[m[32m    status = models.CharField([m
[32m+[m[32m        max_length=10,[m
[32m+[m[32m        choices=Status.choices[m
[32m+[m[32m    )[m
[32m+[m[32m    successful_runs = models.IntegerField(null=True)[m
[32m+[m
[32m+[m[32m   # class StatusInJobs(models.TextChoices):[m
[32m+[m[32m   #      ACTIVE = 'active', _('Active'),[m
[32m+[m[32m   #      CANCELLED = 'cancelled', _('Cancelled'),[m
[32m+[m[32m   #      DELIVERED = 'delivered', _('Delivered'),[m
[32m+[m[32m   #      PAUSED = 'paused', _('Paused'),[m
[32m+[m[32m   #      READY = 'ready', _('Ready'),[m
[32m+[m[32m   #      REVERTED = 'reverted', _('Reverted')[m
[32m+[m[32m   #[m
[32m+[m[32m   #  user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="indsutry_jobs")[m
[32m+[m[32m   #  activity_id = models.IntegerField()[m
[32m+[m[32m   #  blueprint_id = models.BigIntegerField()[m
[32m+[m[32m   #  blueprint_location_id = models.BigIntegerField()[m
[32m+[m[32m   #  blueprint_type_id = models.BigIntegerField()[m
[32m+[m[32m   #  completed_character_id = models.IntegerField()[m
[32m+[m[32m   #  completed_data = models.DateTimeField()[m
[32m+[m[32m   #  cost = models.DecimalField(max_digits=13, decimal_places=4)[m
[32m+[m[32m   #  duration = models.IntegerField()[m
[32m+[m[32m   #  end_date = models.DateTimeField()[m
[32m+[m[32m   #  facility_id = models.BigIntegerField()[m
[32m+[m[32m   #  installer_id = models.IntegerField()[m
[32m+[m[32m   #  job_id = models.IntegerField()[m
[32m+[m[32m   #  licensed_runs = models.IntegerField()[m
[32m+[m[32m   #  output_location_id = models.BigIntegerField()[m
[32m+[m[32m   #  pause_date = models.DateTimeField()[m
[32m+[m[32m   #  probability = models.IntegerField()[m
[32m+[m[32m   #  product_type_id = models.IntegerField()[m
[32m+[m[32m   #  runs = models.IntegerField()[m
[32m+[m[32m   #  start_date = models.DateTimeField()[m
[32m+[m[32m   #  station_id = models.BigIntegerField()[m
[32m+[m[32m   #  status = models.CharField([m
[32m+[m[32m   #      max_length=10,[m
[32m+[m[32m   #      choices=StatusInJobs.choices[m
[32m+[m[32m   #  )[m
[32m+[m[32m   #  successful_runs = models.IntegerField()[m
[32m+[m
[32m+[m
[1mdiff --git a/industry_alert/esi/serializers.py b/industry_alert/esi/serializers.py[m
[1mnew file mode 100644[m
[1mindex 0000000..ff1a29e[m
[1m--- /dev/null[m
[1m+++ b/industry_alert/esi/serializers.py[m
[36m@@ -0,0 +1,94 @@[m
[32m+[m[32mfrom rest_framework import serializers[m
[32m+[m[32mfrom .models import IndustryJob[m
[32m+[m
[32m+[m[32m# atomic[m
[32m+[m[32mfrom django.db import transaction[m
[32m+[m
[32m+[m
[32m+[m[32mclass IndustryJobListSerializer(serializers.ListSerializer):[m
[32m+[m[32m    # https://wikidocs.net/21054[m
[32m+[m[32m    # 이거를 그냥 하면 이 함수를 불러올때마다 스택에 올렸다 내렸다하니[m
[32m+[m[32m    # @staticmethod로 힙에 올려버리기[m
[32m+[m[32m    # 지금은 작아서 상관없는데 커지면 유의미해짐[m
[32m+[m[32m    @staticmethod[m
[32m+[m[32m    def set_status(job, new_status):[m
[32m+[m[32m        job.status = new_status[m
[32m+[m[32m        return job[m
[32m+[m
[32m+[m[32m    # atomic allows us to create a block of code within which the atomicity on the database is guaranteed.[m
[32m+[m[32m    # 이 함수는 atomic하게 transaction처리함[m
[32m+[m[32m    # https://docs.djangoproject.com/en/3.2/topics/db/transactions/#order-of-execution[m
[32m+[m[32m    @transaction.atomic[m
[32m+[m[32m    def create(self, validated_data):[m
[32m+[m[32m        print("in serializer validated_data = ", validated_data)[m
[32m+[m
[32m+[m[32m        # 유저에 대해서 저장된 잡이 있는지 확인[m
[32m+[m[32m        # filter에서는 db hit 안함[m
[32m+[m[32m        # 이거 찍어보면 queryset 오브젝트 나오고 하나 get하기전에는 db에서 값을 가져오지 않음[m
[32m+[m[32m        # https://docs.djangoproject.com/en/3.2/ref/models/querysets/[m
[32m+[m[32m        # evaluate할때만 db랑 통신함[m
[32m+[m[32m        instance = IndustryJob.objects.filter(user=validated_data[0]['user'])[m
[32m+[m[32m        # 유저에 대해서 저장된 잡이 있으면[m
[32m+[m[32m        if instance.exists():[m
[32m+[m[32m            # 기존에 존재하는 job들을 job_id를 key로 정리[m
[32m+[m[32m            # 여기서 iterate하니  db hit 하는거임[m
[32m+[m[32m            job_mapping = {job.job_id: job for job in instance}[m
[32m+[m[32m            # 새로 받아온 job들을 job_id를 키로 정리[m
[32m+[m[32m            data_mapping = {item['job_id']: item for item in validated_data}[m
[32m+[m
[32m+[m[32m            # 새로 받아온 job이 db에 저장되어 있는지 확인하고 없으면 생성[m
[32m+[m[32m            need_create = [[m
[32m+[m[32m                IndustryJob(**data) for job_id, data in data_mapping.items() if job_mapping.get(job_id) is None[m
[32m+[m[32m            ][m
[32m+[m[32m            # 이거 []들어가면 실행안하고 끝나서 if need_crate: 이렇게 안해도됨[m
[32m+[m[32m            IndustryJob.objects.bulk_create(need_create)[m
[32m+[m
[32m+[m[32m            # 새로 받아온 job이 db에 저장되어 있고 status가 변경 됐으면 update 해줌[m
[32m+[m[32m            # 이거 staticmethod는 불러올때 크래스명[m
[32m+[m[32m            need_update = [[m
[32m+[m[32m                IndustryJobListSerializer.set_status(job, data_mapping[job_id]['status']) for job_id, job in job_mapping.items()[m
[32m+[m[32m                if job_id in data_mapping.keys() and job.status != data_mapping[job_id]['status'][m
[32m+[m[32m            ][m
[32m+[m[32m            IndustryJob.objects.bulk_update(need_update, ['status'])[m
[32m+[m
[32m+[m[32m            # 이미 있는 잡이 새로 불러온 job에 없으면 완료되서 사라진거니 삭제해줌[m
[32m+[m[32m            # 이거 python gc가 reference기반이어서 아래에서 더이상 안쓰면 알아서 지워줌[m
[32m+[m[32m            # 아래 리스트 만들면서 job.delete() 실행하고 다음줄 내려가면서 메모리에서 날아감[m
[32m+[m[32m            [job.delete() for job_id, job in job_mapping.items() if job_id not in data_mapping][m
[32m+[m
[32m+[m[32m            # bulk_create, bulk_update의 리턴값을 넘겨주지말고 그냥 이렇게 해도됨[m
[32m+[m[32m            # 실제로 생성된 것도 아니니까 생성전 데이터만 넣어주기[m
[32m+[m[32m            ret = [*need_create, *need_update][m
[32m+[m[32m            if ret:[m
[32m+[m[32m                return ret[m
[32m+[m[32m            return validated_data[m
[32m+[m
[32m+[m[32m        # 유저에 대해서 잡이 없으면 create[m
[32m+[m[32m        industry_jobs = [IndustryJob(**item) for item in validated_data][m
[32m+[m[32m        return IndustryJob.objects.bulk_create(industry_jobs)[m
[32m+[m
[32m+[m[32mclass IndustryJobSerializer(serializers.ModelSerializer):[m
[32m+[m[32m    # 이거 id 기본으로는 read_only여가지고 이렇게 해줘야함[m
[32m+[m[32m    # id = serializers.IntegerField()[m
[32m+[m[32m    completed_character_id = serializers.IntegerField(required=False)[m
[32m+[m[32m    completed_date = serializers.DateTimeField(required=False)[m
[32m+[m[32m    cost = serializers.DecimalField(max_digits=13, decimal_places=4, required=False)[m
[32m+[m[32m    licensed_runs = serializers.IntegerField(required=False)[m
[32m+[m[32m    pause_date = serializers.DateTimeField(required=False)[m
[32m+[m[32m    probability = serializers.FloatField(required=False)[m
[32m+[m[32m    product_type_id = serializers.IntegerField(required=False)[m
[32m+[m[32m    successful_runs = serializers.IntegerField(required=False)[m
[32m+[m
[32m+[m[32m    class Meta:[m
[32m+[m[32m        list_serializer_class = IndustryJobListSerializer[m
[32m+[m[32m        model = IndustryJob[m
[32m+[m[32m        # 이거 context로 user넣어줄거라서 user일단 fields에서 뺌[m
[32m+[m[32m        fields = ['id', 'activity_id', 'blueprint_id', 'blueprint_location_id', 'blueprint_type_id',[m
[32m+[m[32m                  'completed_character_id', 'completed_date', 'cost',[m
[32m+[m[32m                  'duration', 'end_date', 'facility_id', 'installer_id', 'job_id', 'licensed_runs', 'output_location_id',[m
[32m+[m[32m                  'pause_date', 'probability', 'product_type_id', 'runs', 'start_date', 'station_id', 'status',[m
[32m+[m[32m                  'successful_runs'][m
[32m+[m
[32m+[m[32m    def validate(self, attr):[m
[32m+[m[32m        attr['user'] = self.context['user'][m
[32m+[m[32m        return attr[m
\ No newline at end of file[m
[1mdiff --git a/industry_alert/esi/tests.py b/industry_alert/esi/tests.py[m
[1mnew file mode 100644[m
[1mindex 0000000..7ce503c[m
[1m--- /dev/null[m
[1m+++ b/industry_alert/esi/tests.py[m
[36m@@ -0,0 +1,3 @@[m
[32m+[m[32mfrom django.test import TestCase[m
[32m+[m
[32m+[m[32m# Create your tests here.[m
[1mdiff --git a/industry_alert/esi/urls.py b/industry_alert/esi/urls.py[m
[1mnew file mode 100644[m
[1mindex 0000000..c0b128a[m
[1m--- /dev/null[m
[1m+++ b/industry_alert/esi/urls.py[m
[36m@@ -0,0 +1,14 @@[m
[32m+[m[32mfrom django.urls import path[m
[32m+[m[32mfrom django.urls import include # re_path용[m
[32m+[m[32m#  blog 애플리케이션에서 사용할 모든 views를 가져왔어요[m
[32m+[m[32mfrom . import views[m
[32m+[m
[32m+[m[32m# drf[m
[32m+[m[32mfrom rest_framework.routers import DefaultRouter[m
[32m+[m
[32m+[m[32mrouter = DefaultRouter(trailing_slash=False)[m
[32m+[m[32mrouter.register(r'industry/jobs', views.IndustryJobViewSet, basename='industry_jobs')[m
[32m+[m
[32m+[m[32murlpatterns = [[m
[32m+[m[32m    path('api/v1/', include(router.urls)),[m
[32m+[m[32m][m
[1mdiff --git a/industry_alert/esi/views.py b/industry_alert/esi/views.py[m
[1mnew file mode 100644[m
[1mindex 0000000..81d7e8e[m
[1m--- /dev/null[m
[1m+++ b/industry_alert/esi/views.py[m
[36m@@ -0,0 +1,96 @@[m
[32m+[m[32mfrom django.shortcuts import render, get_object_or_404[m
[32m+[m[32mfrom django.utils import timezone # timezone.now() 사용하기 위함임[m
[32m+[m
[32m+[m[32mfrom .models import IndustryJob[m
[32m+[m[32mfrom .serializers import IndustryJobSerializer[m
[32m+[m
[32m+[m[32m# 여기부터 drf viewset 적용위한거임[m
[32m+[m[32mfrom rest_framework import viewsets, serializers, status[m
[32m+[m[32mfrom rest_framework.decorators import action[m
[32m+[m[32mfrom rest_framework.response import Response[m
[32m+[m
[32m+[m
[32m+[m[32mclass IndustryJobViewSet(viewsets.GenericViewSet):[m
[32m+[m[32m    queryset = IndustryJob.objects.all()[m
[32m+[m[32m    serializer_class = IndustryJobSerializer[m
[32m+[m
[32m+[m[32m    # http GET http://127.0.0.1:8000/api/v1/post "Authorization: Token 65b51c4fbf5914eda00efdeb7828842dd0d4dcc6"[m
[32m+[m[32m    def list(self, request):[m
[32m+[m[32m        queryset = self.get_queryset()[m
[32m+[m[32m        serializer = self.get_serializer(queryset, many=True)[m
[32m+[m[32m        return Response(serializer.data)[m
[32m+[m
[32m+[m[32m    # http GET http://127.0.0.1:8000/api/v1/post/<int:pk>[m
[32m+[m[32m    def retrieve(self, request, pk):[m
[32m+[m[32m        instance = self.get_object()[m
[32m+[m[32m        serializer = self.get_serializer(instance)[m
[32m+[m[32m        return Response(serializer.data)[m
[32m+[m
[32m+[m[32m    # http GET http://127.0.0.1:8000/api/v1/post/published "Authorization: Token 65b51c4fbf5914eda00efdeb7828842dd0d4dcc6"[m
[32m+[m[32m    # 이거 /api/v1/post/published로 등록됨[m
[32m+[m[32m    # 그리고 이전에 했던 것 처럼 cur_user = UserSerializer(request.user) 이렇게 시리얼라이져 탈 필요없음[m
[32m+[m[32m    # 왜냐면 request.user가 실제 User 인스턴스라서 걍 바로 넣어도 됨[m
[32m+[m[32m    @action(methods=['get'], detail=False, url_path='users_jobs')[m
[32m+[m[32m    def get_users_industry_jobs(self, request):[m
[32m+[m[32m        queryset = self.get_queryset().filter(user=request.user)[m
[32m+[m[32m        serializer = self.get_serializer(queryset, many=True)[m
[32m+[m[